<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>Rawsock library: Rawsock_lib/rawsock.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="Rawsock_lib_logo.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Rawsock library
   &#160;<span id="projectnumber">v0.3.4</span>
   </div>
   <div id="projectbrief">Library to make the use of raw sockets easier, under Linux. Currently supporting IPv4, UDP and a custom latency measurement protocol (LaMP - supported both in raw and non-raw sockets).</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('rawsock_8h.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">rawsock.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &lt;net/ethernet.h&gt;</code><br />
<code>#include &lt;linux/udp.h&gt;</code><br />
<code>#include &lt;linux/ip.h&gt;</code><br />
<code>#include &lt;arpa/inet.h&gt;</code><br />
<code>#include &lt;stdio.h&gt;</code><br />
<code>#include &lt;stdbool.h&gt;</code><br />
<code>#include &lt;string.h&gt;</code><br />
</div>
<p><a href="rawsock_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structipaddrs.html">ipaddrs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure to store a couple of source and destinaion IPv4 addresses.  <a href="structipaddrs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ac7b68a1e0ffd7ae30f3848d1bd582837"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rawsock_8h.html#ac7b68a1e0ffd7ae30f3848d1bd582837">MAC_FILE_PATH_SIZE</a>&#160;&#160;&#160;23</td></tr>
<tr class="separator:ac7b68a1e0ffd7ae30f3848d1bd582837"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae01dbae885bc8abecb82bd865515c081"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rawsock_8h.html#ae01dbae885bc8abecb82bd865515c081">MAC_ADDR_SIZE</a>&#160;&#160;&#160;6</td></tr>
<tr class="separator:ae01dbae885bc8abecb82bd865515c081"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6423a4df1e8aed89332dfdf9b6436cb"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rawsock_8h.html#ad6423a4df1e8aed89332dfdf9b6436cb">ERR_WLAN_NOIF</a>&#160;&#160;&#160;0</td></tr>
<tr class="separator:ad6423a4df1e8aed89332dfdf9b6436cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52922b300bbc95f471c2cde6e9213a2c"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rawsock_8h.html#a52922b300bbc95f471c2cde6e9213a2c">ERR_WLAN_SOCK</a>&#160;&#160;&#160;-1</td></tr>
<tr class="separator:a52922b300bbc95f471c2cde6e9213a2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21e778534653ff83888669f1d6606a5f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rawsock_8h.html#a21e778534653ff83888669f1d6606a5f">ERR_WLAN_GETIFADDRS</a>&#160;&#160;&#160;-2</td></tr>
<tr class="separator:a21e778534653ff83888669f1d6606a5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a298bd4822ba623995ce6d17e44dcdb6a"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rawsock_8h.html#a298bd4822ba623995ce6d17e44dcdb6a">ERR_WLAN_INDEX</a>&#160;&#160;&#160;-3</td></tr>
<tr class="separator:a298bd4822ba623995ce6d17e44dcdb6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaefa4462ab0b860b6bd0bbfc22d5cd33"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rawsock_8h.html#aaefa4462ab0b860b6bd0bbfc22d5cd33">ERR_WLAN_GETSRCMAC</a>&#160;&#160;&#160;-4</td></tr>
<tr class="separator:aaefa4462ab0b860b6bd0bbfc22d5cd33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93ff51a7c2a9b546fd2453e2132ee133"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rawsock_8h.html#a93ff51a7c2a9b546fd2453e2132ee133">ERR_WLAN_GETIFINDEX</a>&#160;&#160;&#160;-5</td></tr>
<tr class="separator:a93ff51a7c2a9b546fd2453e2132ee133"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa18e60a5bdd3f8649877c4921b08c050"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rawsock_8h.html#aa18e60a5bdd3f8649877c4921b08c050">ERR_WLAN_GETSRCIP</a>&#160;&#160;&#160;-6</td></tr>
<tr class="separator:aa18e60a5bdd3f8649877c4921b08c050"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5030ae5a9bf30b1f2c4ee41081bdcc2"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rawsock_8h.html#ab5030ae5a9bf30b1f2c4ee41081bdcc2">ERR_IPHEAD_SOCK</a>&#160;&#160;&#160;-10</td></tr>
<tr class="separator:ab5030ae5a9bf30b1f2c4ee41081bdcc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb4547c3913540def3246e79da5e8e01"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rawsock_8h.html#afb4547c3913540def3246e79da5e8e01">ERR_IPHEAD_NOSRCADDR</a>&#160;&#160;&#160;-11</td></tr>
<tr class="separator:afb4547c3913540def3246e79da5e8e01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d04863a699cd0ba36a4bad72f87875b"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rawsock_8h.html#a4d04863a699cd0ba36a4bad72f87875b">ERR_VIFPRINTER_SOCK</a>&#160;&#160;&#160;-20</td></tr>
<tr class="separator:a4d04863a699cd0ba36a4bad72f87875b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29814c440e4009d26f00f2073988f503"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rawsock_8h.html#a29814c440e4009d26f00f2073988f503">ERR_VIFPRINTER_GETIFADDRS</a>&#160;&#160;&#160;-21</td></tr>
<tr class="separator:a29814c440e4009d26f00f2073988f503"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa13ccea41ef8a2be5418a024491ab3cb"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rawsock_8h.html#aa13ccea41ef8a2be5418a024491ab3cb">WLANLOOKUP_WLAN</a>&#160;&#160;&#160;0</td></tr>
<tr class="separator:aa13ccea41ef8a2be5418a024491ab3cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a4daab19d5e118e848deaa847b17646"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rawsock_8h.html#a8a4daab19d5e118e848deaa847b17646">WLANLOOKUP_NONWLAN</a>&#160;&#160;&#160;1</td></tr>
<tr class="separator:a8a4daab19d5e118e848deaa847b17646"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addf164de7bf1717f1fea7fc8c131df8c"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rawsock_8h.html#addf164de7bf1717f1fea7fc8c131df8c">MAC_NULL</a>&#160;&#160;&#160;0x00</td></tr>
<tr class="separator:addf164de7bf1717f1fea7fc8c131df8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad085edcd01bf33b3ac926fd440ff5faf"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rawsock_8h.html#ad085edcd01bf33b3ac926fd440ff5faf">MAC_BROADCAST</a>&#160;&#160;&#160;0x01</td></tr>
<tr class="separator:ad085edcd01bf33b3ac926fd440ff5faf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa97ac5e7eaefc0ee2f00af097bf2ce62"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rawsock_8h.html#aa97ac5e7eaefc0ee2f00af097bf2ce62">MAC_UNICAST</a>&#160;&#160;&#160;0x02</td></tr>
<tr class="separator:aa97ac5e7eaefc0ee2f00af097bf2ce62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0e8fb4c350b55365bc0fd1b5d79574c"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rawsock_8h.html#ac0e8fb4c350b55365bc0fd1b5d79574c">MAC_MULTICAST</a>&#160;&#160;&#160;0x03</td></tr>
<tr class="separator:ac0e8fb4c350b55365bc0fd1b5d79574c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b505fc6e4743303fac564fe419e11be"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rawsock_8h.html#a7b505fc6e4743303fac564fe419e11be">MAC_ZERO</a>&#160;&#160;&#160;0x04</td></tr>
<tr class="separator:a7b505fc6e4743303fac564fe419e11be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa87616dfe8685a4b5f240c19846fe22e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rawsock_8h.html#aa87616dfe8685a4b5f240c19846fe22e">ETHERTYPE_GEONET</a>&#160;&#160;&#160;0x8947</td></tr>
<tr class="separator:aa87616dfe8685a4b5f240c19846fe22e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c5a3ec926358ac4b8fcd91cf32d9601"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rawsock_8h.html#a1c5a3ec926358ac4b8fcd91cf32d9601">ETHERTYPE_WSMP</a>&#160;&#160;&#160;0x88DC</td></tr>
<tr class="separator:a1c5a3ec926358ac4b8fcd91cf32d9601"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff64daee24d50575c816c5d75874d001"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rawsock_8h.html#aff64daee24d50575c816c5d75874d001">WLANLOOKUP_LOOPBACK</a>&#160;&#160;&#160;-1</td></tr>
<tr class="separator:aff64daee24d50575c816c5d75874d001"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a340376f4c1c554ce0ed8a56353245f87"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rawsock_8h.html#a340376f4c1c554ce0ed8a56353245f87">BASIC_IHL</a>&#160;&#160;&#160;5</td></tr>
<tr class="separator:a340376f4c1c554ce0ed8a56353245f87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3d82b086c0b0e4ddac202078f01f120"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rawsock_8h.html#ae3d82b086c0b0e4ddac202078f01f120">IPV4</a>&#160;&#160;&#160;4</td></tr>
<tr class="separator:ae3d82b086c0b0e4ddac202078f01f120"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ac68536910e3f9ad37e12294f7aaff0"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rawsock_8h.html#a6ac68536910e3f9ad37e12294f7aaff0">BASIC_UDP_TTL</a>&#160;&#160;&#160;64</td></tr>
<tr class="separator:a6ac68536910e3f9ad37e12294f7aaff0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a179d15dbd6876292449c2b92d61e35f7"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rawsock_8h.html#a179d15dbd6876292449c2b92d61e35f7">UDPHEADERLEN</a>&#160;&#160;&#160;8</td></tr>
<tr class="separator:a179d15dbd6876292449c2b92d61e35f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5483704d4c1b6c832db99ffe700b1345"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rawsock_8h.html#a5483704d4c1b6c832db99ffe700b1345">FLAG_NOFRAG_MASK</a>&#160;&#160;&#160;(1&lt;&lt;6)</td></tr>
<tr class="separator:a5483704d4c1b6c832db99ffe700b1345"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d605dd366ed60554963ef178a7787ad"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rawsock_8h.html#a3d605dd366ed60554963ef178a7787ad">FLAG_RESERVED_MASK</a>&#160;&#160;&#160;(1&lt;&lt;7)</td></tr>
<tr class="separator:a3d605dd366ed60554963ef178a7787ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a078b5997c266ca75d55abbad2d8d7462"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rawsock_8h.html#a078b5997c266ca75d55abbad2d8d7462">FLAG_MOREFRAG_MASK</a>&#160;&#160;&#160;(1&lt;&lt;5)</td></tr>
<tr class="separator:a078b5997c266ca75d55abbad2d8d7462"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c2ebe239a3b502d61f5ba607a8db4e6"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rawsock_8h.html#a9c2ebe239a3b502d61f5ba607a8db4e6">CSUM_IP</a>&#160;&#160;&#160;0x00</td></tr>
<tr class="separator:a9c2ebe239a3b502d61f5ba607a8db4e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a848a2c02ec2f354018a998c3d87d2836"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rawsock_8h.html#a848a2c02ec2f354018a998c3d87d2836">CSUM_UDP</a>&#160;&#160;&#160;0x01</td></tr>
<tr class="separator:a848a2c02ec2f354018a998c3d87d2836"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5815136097e443a0a41d35d9c1d5389"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rawsock_8h.html#aa5815136097e443a0a41d35d9c1d5389">CSUM_UDPIP</a>&#160;&#160;&#160;0x80</td></tr>
<tr class="separator:aa5815136097e443a0a41d35d9c1d5389"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc14ca0cde20d80e340db369d21aa9b9"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rawsock_8h.html#adc14ca0cde20d80e340db369d21aa9b9">PRI_MAC</a>&#160;&#160;&#160;&quot;%02x:%02x:%02x:%02x:%02x:%02x&quot;</td></tr>
<tr class="separator:adc14ca0cde20d80e340db369d21aa9b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f6afdfc5a1697437de7c81eec02881a"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rawsock_8h.html#a5f6afdfc5a1697437de7c81eec02881a">MAC_PRINTER</a>(mac_array)&#160;&#160;&#160;mac_array[0], mac_array[1], mac_array[2], mac_array[3], mac_array[4], mac_array[5]</td></tr>
<tr class="separator:a5f6afdfc5a1697437de7c81eec02881a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9b222932e933c2a3dac81ed9aeb8ded"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rawsock_8h.html#ac9b222932e933c2a3dac81ed9aeb8ded">SCN_MAC</a>&#160;&#160;&#160;&quot;%x:%x:%x:%x:%x:%x%*c&quot;</td></tr>
<tr class="separator:ac9b222932e933c2a3dac81ed9aeb8ded"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8809fd8c4ef6f730bcc908229f08a072"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rawsock_8h.html#a8809fd8c4ef6f730bcc908229f08a072">MAC_SCANNER</a>(mac_array)&#160;&#160;&#160;&amp;mac_array[0], &amp;mac_array[1], &amp;mac_array[2], &amp;mac_array[3], &amp;mac_array[4], &amp;mac_array[5]</td></tr>
<tr class="separator:a8809fd8c4ef6f730bcc908229f08a072"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbbb2b8b10ab4740a9f6c62b93cfef66"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rawsock_8h.html#acbbb2b8b10ab4740a9f6c62b93cfef66">UDP_PACKET_SIZE</a>(data)&#160;&#160;&#160;sizeof(struct udphdr)+sizeof(data)</td></tr>
<tr class="separator:acbbb2b8b10ab4740a9f6c62b93cfef66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af556407e9c582f485d45f219df9cfc1f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rawsock_8h.html#af556407e9c582f485d45f219df9cfc1f">IP_UDP_PACKET_SIZE</a>(data)&#160;&#160;&#160;sizeof(struct iphdr)+sizeof(struct udphdr)+sizeof(data)</td></tr>
<tr class="separator:af556407e9c582f485d45f219df9cfc1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fe57c8dc5a044a3a1fdfae20ccc8bad"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rawsock_8h.html#a6fe57c8dc5a044a3a1fdfae20ccc8bad">ETH_IP_UDP_PACKET_SIZE</a>(data)&#160;&#160;&#160;sizeof(struct ether_header)+sizeof(struct iphdr)+sizeof(struct udphdr)+sizeof(data)</td></tr>
<tr class="separator:a6fe57c8dc5a044a3a1fdfae20ccc8bad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20da24fd44ae674c4d8373e58685c573"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rawsock_8h.html#a20da24fd44ae674c4d8373e58685c573">UDP_PACKET_SIZE_S</a>(size)&#160;&#160;&#160;sizeof(struct udphdr)+size</td></tr>
<tr class="separator:a20da24fd44ae674c4d8373e58685c573"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af223f5e314af4eabc6d66cc8ee02a3a0"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rawsock_8h.html#af223f5e314af4eabc6d66cc8ee02a3a0">IP_UDP_PACKET_SIZE_S</a>(size)&#160;&#160;&#160;sizeof(struct iphdr)+sizeof(struct udphdr)+size</td></tr>
<tr class="separator:af223f5e314af4eabc6d66cc8ee02a3a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66f2e41ccb093addf0db42970af74b42"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rawsock_8h.html#a66f2e41ccb093addf0db42970af74b42">ETH_IP_UDP_PACKET_SIZE_S</a>(size)&#160;&#160;&#160;sizeof(struct ether_header)+sizeof(struct iphdr)+sizeof(struct udphdr)+size</td></tr>
<tr class="separator:a66f2e41ccb093addf0db42970af74b42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e1f9f0fd436e762641718456852ee80"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8e1f9f0fd436e762641718456852ee80"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>BYTE_TYPE</b></td></tr>
<tr class="separator:a8e1f9f0fd436e762641718456852ee80"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a0661d7d1353e0bca70c64563f635b034"><td class="memItemLeft" align="right" valign="top">typedef uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rawsock_8h.html#a0661d7d1353e0bca70c64563f635b034">byte_t</a></td></tr>
<tr class="separator:a0661d7d1353e0bca70c64563f635b034"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7516f6c5689b1c204b2bb4f05b09e1cf"><td class="memItemLeft" align="right" valign="top">typedef uint8_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rawsock_8h.html#a7516f6c5689b1c204b2bb4f05b09e1cf">macaddr_t</a></td></tr>
<tr class="separator:a7516f6c5689b1c204b2bb4f05b09e1cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23bd834253bb70c8f0f64c79aed350b9"><td class="memItemLeft" align="right" valign="top">typedef unsigned short&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rawsock_8h.html#a23bd834253bb70c8f0f64c79aed350b9">ethertype_t</a></td></tr>
<tr class="separator:a23bd834253bb70c8f0f64c79aed350b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69f2206781eb90dcf48b8be85a62f900"><td class="memItemLeft" align="right" valign="top">typedef int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rawsock_8h.html#a69f2206781eb90dcf48b8be85a62f900">rawsockerr_t</a></td></tr>
<tr class="separator:a69f2206781eb90dcf48b8be85a62f900"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2241201dc140b721a522eaf39d9e527"><td class="memItemLeft" align="right" valign="top">typedef unsigned char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rawsock_8h.html#aa2241201dc140b721a522eaf39d9e527">csumt_t</a></td></tr>
<tr class="separator:aa2241201dc140b721a522eaf39d9e527"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71cbed2832d72fff127aa670c21cd79b"><td class="memItemLeft" align="right" valign="top">typedef __sum16&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rawsock_8h.html#a71cbed2832d72fff127aa670c21cd79b">csum16_t</a></td></tr>
<tr class="separator:a71cbed2832d72fff127aa670c21cd79b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a91e19fa4fff461493e1a41f7c7aa4e5f"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rawsock_8h.html#a91e19fa4fff461493e1a41f7c7aa4e5f">protocol_t</a> { <a class="el" href="rawsock_8h.html#a91e19fa4fff461493e1a41f7c7aa4e5fa0e207f13266615a67248e0872a857e22">UNSET_P</a>, 
<a class="el" href="rawsock_8h.html#a91e19fa4fff461493e1a41f7c7aa4e5fadb542475cf9d0636e4225e216cee9ae6">UDP</a>, 
<a class="el" href="rawsock_8h.html#a91e19fa4fff461493e1a41f7c7aa4e5faab84bdffa9f13502c4a851f15c80a90c">AMQP_0_9</a>, 
<a class="el" href="rawsock_8h.html#a91e19fa4fff461493e1a41f7c7aa4e5fa99b2d1c97e1d5b77bc8038106a70c053">AMQP_1_0</a>
 }<tr class="memdesc:a91e19fa4fff461493e1a41f7c7aa4e5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Protocol type enumerator.  <a href="rawsock_8h.html#a91e19fa4fff461493e1a41f7c7aa4e5f">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:a91e19fa4fff461493e1a41f7c7aa4e5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a67042209a2494ae4c50c5e4317888226"><td class="memItemLeft" align="right" valign="top"><a class="el" href="rawsock_8h.html#a69f2206781eb90dcf48b8be85a62f900">rawsockerr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rawsock_8h.html#a67042209a2494ae4c50c5e4317888226">wlanLookup</a> (char *devname, int *ifindex, <a class="el" href="rawsock_8h.html#a7516f6c5689b1c204b2bb4f05b09e1cf">macaddr_t</a> mac, struct in_addr *srcIP, int index, int mode)</td></tr>
<tr class="memdesc:a67042209a2494ae4c50c5e4317888226"><td class="mdescLeft">&#160;</td><td class="mdescRight">Automatically look for available WLAN, non-WLAN or loopback interfaces.  <a href="#a67042209a2494ae4c50c5e4317888226">More...</a><br /></td></tr>
<tr class="separator:a67042209a2494ae4c50c5e4317888226"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad9c02628ca1d54590c3bececec86b57"><td class="memItemLeft" align="right" valign="top"><a class="el" href="rawsock_8h.html#a69f2206781eb90dcf48b8be85a62f900">rawsockerr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rawsock_8h.html#aad9c02628ca1d54590c3bececec86b57">vifPrinter</a> (FILE *stream)</td></tr>
<tr class="memdesc:aad9c02628ca1d54590c3bececec86b57"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print information about available interfaces.  <a href="#aad9c02628ca1d54590c3bececec86b57">More...</a><br /></td></tr>
<tr class="separator:aad9c02628ca1d54590c3bececec86b57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9ffe247a4f65a16e4bf123104e8105e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="rawsock_8h.html#a7516f6c5689b1c204b2bb4f05b09e1cf">macaddr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rawsock_8h.html#af9ffe247a4f65a16e4bf123104e8105e">prepareMacAddrT</a> ()</td></tr>
<tr class="memdesc:af9ffe247a4f65a16e4bf123104e8105e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prepare a <em>macaddr_t</em> variable.  <a href="#af9ffe247a4f65a16e4bf123104e8105e">More...</a><br /></td></tr>
<tr class="separator:af9ffe247a4f65a16e4bf123104e8105e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af86e3c8e9300732f7222fcce3b08adad"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rawsock_8h.html#af86e3c8e9300732f7222fcce3b08adad">macAddrTypeGet</a> (<a class="el" href="rawsock_8h.html#a7516f6c5689b1c204b2bb4f05b09e1cf">macaddr_t</a> mac)</td></tr>
<tr class="memdesc:af86e3c8e9300732f7222fcce3b08adad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the MAC address type.  <a href="#af86e3c8e9300732f7222fcce3b08adad">More...</a><br /></td></tr>
<tr class="separator:af86e3c8e9300732f7222fcce3b08adad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed9676022fd046d34e243cf52cfd8255"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rawsock_8h.html#aed9676022fd046d34e243cf52cfd8255">freeMacAddrT</a> (<a class="el" href="rawsock_8h.html#a7516f6c5689b1c204b2bb4f05b09e1cf">macaddr_t</a> mac)</td></tr>
<tr class="memdesc:aed9676022fd046d34e243cf52cfd8255"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free a <em>macaddr_t</em> variable.  <a href="#aed9676022fd046d34e243cf52cfd8255">More...</a><br /></td></tr>
<tr class="separator:aed9676022fd046d34e243cf52cfd8255"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af596c860215789d5a99e419fa69a0500"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rawsock_8h.html#af596c860215789d5a99e419fa69a0500">rs_printerror</a> (FILE *stream, <a class="el" href="rawsock_8h.html#a69f2206781eb90dcf48b8be85a62f900">rawsockerr_t</a> code)</td></tr>
<tr class="memdesc:af596c860215789d5a99e419fa69a0500"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print more detailed error messages.  <a href="#af596c860215789d5a99e419fa69a0500">More...</a><br /></td></tr>
<tr class="separator:af596c860215789d5a99e419fa69a0500"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ca9119d2c4568914340756b5dbeb7ce"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rawsock_8h.html#a1ca9119d2c4568914340756b5dbeb7ce">display_packet</a> (const char *text, <a class="el" href="rawsock_8h.html#a0661d7d1353e0bca70c64563f635b034">byte_t</a> *packet, unsigned int len)</td></tr>
<tr class="memdesc:a1ca9119d2c4568914340756b5dbeb7ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Display packet in hexadecimal form.  <a href="#a1ca9119d2c4568914340756b5dbeb7ce">More...</a><br /></td></tr>
<tr class="separator:a1ca9119d2c4568914340756b5dbeb7ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42af111446f0e87c3e72e1cba60d3a24"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rawsock_8h.html#a42af111446f0e87c3e72e1cba60d3a24">display_packetc</a> (const char *text, <a class="el" href="rawsock_8h.html#a0661d7d1353e0bca70c64563f635b034">byte_t</a> *packet, unsigned int len)</td></tr>
<tr class="memdesc:a42af111446f0e87c3e72e1cba60d3a24"><td class="mdescLeft">&#160;</td><td class="mdescRight">Display packet in character form.  <a href="#a42af111446f0e87c3e72e1cba60d3a24">More...</a><br /></td></tr>
<tr class="separator:a42af111446f0e87c3e72e1cba60d3a24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02a011504fe087e9d13aff96a26017c7"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rawsock_8h.html#a02a011504fe087e9d13aff96a26017c7">hton64</a> (uint64_t hostu64)</td></tr>
<tr class="memdesc:a02a011504fe087e9d13aff96a26017c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a 64-bit unsigned value between host and network byte order.  <a href="#a02a011504fe087e9d13aff96a26017c7">More...</a><br /></td></tr>
<tr class="separator:a02a011504fe087e9d13aff96a26017c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a452c0159838860279d7f195c96ca01f2"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rawsock_8h.html#a452c0159838860279d7f195c96ca01f2">ntoh64</a> (uint64_t netu64)</td></tr>
<tr class="memdesc:a452c0159838860279d7f195c96ca01f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a 64-bit unsigned value between network and host byte order.  <a href="#a452c0159838860279d7f195c96ca01f2">More...</a><br /></td></tr>
<tr class="separator:a452c0159838860279d7f195c96ca01f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6dda4611a853da42435df9a025266641"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rawsock_8h.html#a6dda4611a853da42435df9a025266641">etherheadPopulateB</a> (struct ether_header *etherHeader, <a class="el" href="rawsock_8h.html#a7516f6c5689b1c204b2bb4f05b09e1cf">macaddr_t</a> mac, <a class="el" href="rawsock_8h.html#a23bd834253bb70c8f0f64c79aed350b9">ethertype_t</a> type)</td></tr>
<tr class="memdesc:a6dda4611a853da42435df9a025266641"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populate broadcast Ethernet header (variant of <a class="el" href="rawsock_8h.html#ac70b54da68a91bb811cf57d2c27381fd" title="Populate Ethernet header. ">etherheadPopulate()</a>)  <a href="#a6dda4611a853da42435df9a025266641">More...</a><br /></td></tr>
<tr class="separator:a6dda4611a853da42435df9a025266641"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac70b54da68a91bb811cf57d2c27381fd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rawsock_8h.html#ac70b54da68a91bb811cf57d2c27381fd">etherheadPopulate</a> (struct ether_header *etherHeader, <a class="el" href="rawsock_8h.html#a7516f6c5689b1c204b2bb4f05b09e1cf">macaddr_t</a> macsrc, <a class="el" href="rawsock_8h.html#a7516f6c5689b1c204b2bb4f05b09e1cf">macaddr_t</a> macdst, <a class="el" href="rawsock_8h.html#a23bd834253bb70c8f0f64c79aed350b9">ethertype_t</a> type)</td></tr>
<tr class="memdesc:ac70b54da68a91bb811cf57d2c27381fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populate Ethernet header.  <a href="#ac70b54da68a91bb811cf57d2c27381fd">More...</a><br /></td></tr>
<tr class="separator:ac70b54da68a91bb811cf57d2c27381fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3551ee96011895ab6e895381782cb138"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rawsock_8h.html#a3551ee96011895ab6e895381782cb138">etherEncapsulate</a> (<a class="el" href="rawsock_8h.html#a0661d7d1353e0bca70c64563f635b034">byte_t</a> *packet, struct ether_header *header, <a class="el" href="rawsock_8h.html#a0661d7d1353e0bca70c64563f635b034">byte_t</a> *sdu, size_t sdusize)</td></tr>
<tr class="memdesc:a3551ee96011895ab6e895381782cb138"><td class="mdescLeft">&#160;</td><td class="mdescRight">Combine Ethernet SDU and PCI.  <a href="#a3551ee96011895ab6e895381782cb138">More...</a><br /></td></tr>
<tr class="separator:a3551ee96011895ab6e895381782cb138"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14ac66b8c5b58a37f5cbfabec68e317c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rawsock_8h.html#a14ac66b8c5b58a37f5cbfabec68e317c">getSrcMAC</a> (struct ether_header *etherHeader, <a class="el" href="rawsock_8h.html#a7516f6c5689b1c204b2bb4f05b09e1cf">macaddr_t</a> macsrc)</td></tr>
<tr class="memdesc:a14ac66b8c5b58a37f5cbfabec68e317c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve source MAC address field from Ethernet header.  <a href="#a14ac66b8c5b58a37f5cbfabec68e317c">More...</a><br /></td></tr>
<tr class="separator:a14ac66b8c5b58a37f5cbfabec68e317c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae696dee7a0ca07e0872c7e56595e5553"><td class="memItemLeft" align="right" valign="top"><a class="el" href="rawsock_8h.html#a69f2206781eb90dcf48b8be85a62f900">rawsockerr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rawsock_8h.html#ae696dee7a0ca07e0872c7e56595e5553">IP4headPopulateB</a> (struct iphdr *IPhead, char *devname, unsigned char tos, unsigned short frag_offset, unsigned char ttl, unsigned char protocol, unsigned int flags, struct <a class="el" href="structipaddrs.html">ipaddrs</a> *addrs)</td></tr>
<tr class="memdesc:ae696dee7a0ca07e0872c7e56595e5553"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populate broadcast IP version 4 header (variant of <a class="el" href="rawsock_8h.html#a166eb0daab0e332b134c1dff449a9271" title="Populate IP version 4 header. ">IP4headPopulate()</a>)  <a href="#ae696dee7a0ca07e0872c7e56595e5553">More...</a><br /></td></tr>
<tr class="separator:ae696dee7a0ca07e0872c7e56595e5553"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbddc8a0001b2c08908f266d3436e3f0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="rawsock_8h.html#a69f2206781eb90dcf48b8be85a62f900">rawsockerr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rawsock_8h.html#acbddc8a0001b2c08908f266d3436e3f0">IP4headPopulateS</a> (struct iphdr *IPhead, char *devname, struct in_addr destIP, unsigned char tos, unsigned short frag_offset, unsigned char ttl, unsigned char protocol, unsigned int flags, struct <a class="el" href="structipaddrs.html">ipaddrs</a> *addrs)</td></tr>
<tr class="memdesc:acbddc8a0001b2c08908f266d3436e3f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populate IP version 4 header with <em>struct in_addr</em> addresses (variant of <a class="el" href="rawsock_8h.html#a166eb0daab0e332b134c1dff449a9271" title="Populate IP version 4 header. ">IP4headPopulate()</a>)  <a href="#acbddc8a0001b2c08908f266d3436e3f0">More...</a><br /></td></tr>
<tr class="separator:acbddc8a0001b2c08908f266d3436e3f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a166eb0daab0e332b134c1dff449a9271"><td class="memItemLeft" align="right" valign="top"><a class="el" href="rawsock_8h.html#a69f2206781eb90dcf48b8be85a62f900">rawsockerr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rawsock_8h.html#a166eb0daab0e332b134c1dff449a9271">IP4headPopulate</a> (struct iphdr *IPhead, char *devname, char *destIP, unsigned char tos, unsigned short frag_offset, unsigned char ttl, unsigned char protocol, unsigned int flags, struct <a class="el" href="structipaddrs.html">ipaddrs</a> *addrs)</td></tr>
<tr class="memdesc:a166eb0daab0e332b134c1dff449a9271"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populate IP version 4 header.  <a href="#a166eb0daab0e332b134c1dff449a9271">More...</a><br /></td></tr>
<tr class="separator:a166eb0daab0e332b134c1dff449a9271"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30db7ab77625aba3abe06ae33c892715"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rawsock_8h.html#a30db7ab77625aba3abe06ae33c892715">IP4headAddID</a> (struct iphdr *IPhead, unsigned short id)</td></tr>
<tr class="memdesc:a30db7ab77625aba3abe06ae33c892715"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add ID to a given IPv4 header.  <a href="#a30db7ab77625aba3abe06ae33c892715">More...</a><br /></td></tr>
<tr class="separator:a30db7ab77625aba3abe06ae33c892715"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeea7cc65afcd15945e6be31ec0a7f136"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rawsock_8h.html#aeea7cc65afcd15945e6be31ec0a7f136">IP4headAddTotLen</a> (struct iphdr *IPhead, unsigned short len)</td></tr>
<tr class="memdesc:aeea7cc65afcd15945e6be31ec0a7f136"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add Total Length to a given IPv4 header.  <a href="#aeea7cc65afcd15945e6be31ec0a7f136">More...</a><br /></td></tr>
<tr class="separator:aeea7cc65afcd15945e6be31ec0a7f136"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5117600ef5b7603bd169e16a4d305bfa"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rawsock_8h.html#a5117600ef5b7603bd169e16a4d305bfa">IP4Encapsulate</a> (<a class="el" href="rawsock_8h.html#a0661d7d1353e0bca70c64563f635b034">byte_t</a> *packet, struct iphdr *header, <a class="el" href="rawsock_8h.html#a0661d7d1353e0bca70c64563f635b034">byte_t</a> *sdu, size_t sdusize)</td></tr>
<tr class="memdesc:a5117600ef5b7603bd169e16a4d305bfa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Combine IPv4 SDU and PCI.  <a href="#a5117600ef5b7603bd169e16a4d305bfa">More...</a><br /></td></tr>
<tr class="separator:a5117600ef5b7603bd169e16a4d305bfa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6eb7d52837b679a35c818cb2cd93a569"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rawsock_8h.html#a6eb7d52837b679a35c818cb2cd93a569">UDPheadPopulate</a> (struct udphdr *UDPhead, unsigned short sourceport, unsigned short destport)</td></tr>
<tr class="memdesc:a6eb7d52837b679a35c818cb2cd93a569"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populate UDP header.  <a href="#a6eb7d52837b679a35c818cb2cd93a569">More...</a><br /></td></tr>
<tr class="separator:a6eb7d52837b679a35c818cb2cd93a569"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af66696d8e4ee2eb7d09a1eed9497b452"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rawsock_8h.html#af66696d8e4ee2eb7d09a1eed9497b452">UDPencapsulate</a> (<a class="el" href="rawsock_8h.html#a0661d7d1353e0bca70c64563f635b034">byte_t</a> *packet, struct udphdr *header, <a class="el" href="rawsock_8h.html#a0661d7d1353e0bca70c64563f635b034">byte_t</a> *data, size_t payloadsize, struct <a class="el" href="structipaddrs.html">ipaddrs</a> addrs)</td></tr>
<tr class="memdesc:af66696d8e4ee2eb7d09a1eed9497b452"><td class="mdescLeft">&#160;</td><td class="mdescRight">Combine UDP payload and header.  <a href="#af66696d8e4ee2eb7d09a1eed9497b452">More...</a><br /></td></tr>
<tr class="separator:af66696d8e4ee2eb7d09a1eed9497b452"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73f90608054cccd554921c8237479aa2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="rawsock_8h.html#a0661d7d1353e0bca70c64563f635b034">byte_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rawsock_8h.html#a73f90608054cccd554921c8237479aa2">UDPgetpacketpointers</a> (<a class="el" href="rawsock_8h.html#a0661d7d1353e0bca70c64563f635b034">byte_t</a> *pktbuf, struct ether_header **etherHeader, struct iphdr **IPheader, struct udphdr **UDPheader)</td></tr>
<tr class="memdesc:a73f90608054cccd554921c8237479aa2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get pointers to headers and payload in UDP packet buffer.  <a href="#a73f90608054cccd554921c8237479aa2">More...</a><br /></td></tr>
<tr class="separator:a73f90608054cccd554921c8237479aa2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64420c632f0fa00e99aa66db3099823f"><td class="memItemLeft" align="right" valign="top">unsigned short&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rawsock_8h.html#a64420c632f0fa00e99aa66db3099823f">UDPgetpayloadsize</a> (struct udphdr *UDPheader)</td></tr>
<tr class="memdesc:a64420c632f0fa00e99aa66db3099823f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get UDP payload size, given a UDP header.  <a href="#a64420c632f0fa00e99aa66db3099823f">More...</a><br /></td></tr>
<tr class="separator:a64420c632f0fa00e99aa66db3099823f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb14def1a9dd5a7393b77391dddeca13"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rawsock_8h.html#abb14def1a9dd5a7393b77391dddeca13">validateEthCsum</a> (<a class="el" href="rawsock_8h.html#a0661d7d1353e0bca70c64563f635b034">byte_t</a> *packet, <a class="el" href="rawsock_8h.html#a71cbed2832d72fff127aa670c21cd79b">csum16_t</a> csum, <a class="el" href="rawsock_8h.html#a71cbed2832d72fff127aa670c21cd79b">csum16_t</a> *combinedcsum, <a class="el" href="rawsock_8h.html#aa2241201dc140b721a522eaf39d9e527">csumt_t</a> type, void *args)</td></tr>
<tr class="memdesc:abb14def1a9dd5a7393b77391dddeca13"><td class="mdescLeft">&#160;</td><td class="mdescRight">Validate the checksum of a raw "Ethernet" packet, i.e. of any packet containing a <em>struct ether_header</em> as first bytes.  <a href="#abb14def1a9dd5a7393b77391dddeca13">More...</a><br /></td></tr>
<tr class="separator:abb14def1a9dd5a7393b77391dddeca13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40bb53171777fd6d4ade834c512519c5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rawsock_8h.html#a40bb53171777fd6d4ade834c512519c5">test_injectIPCsumError</a> (<a class="el" href="rawsock_8h.html#a0661d7d1353e0bca70c64563f635b034">byte_t</a> *IPpacket)</td></tr>
<tr class="memdesc:a40bb53171777fd6d4ade834c512519c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test function: inject a checksum error in an IP packet.  <a href="#a40bb53171777fd6d4ade834c512519c5">More...</a><br /></td></tr>
<tr class="separator:a40bb53171777fd6d4ade834c512519c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2a34461395e274047f3c605b0aa16b4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rawsock_8h.html#aa2a34461395e274047f3c605b0aa16b4">test_injectUDPCsumError</a> (<a class="el" href="rawsock_8h.html#a0661d7d1353e0bca70c64563f635b034">byte_t</a> *UDPpacket)</td></tr>
<tr class="memdesc:aa2a34461395e274047f3c605b0aa16b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test function: inject a checksum error in an UDP packet.  <a href="#aa2a34461395e274047f3c605b0aa16b4">More...</a><br /></td></tr>
<tr class="separator:aa2a34461395e274047f3c605b0aa16b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This file represents the main header file of the Rawsock library.</p>
<p>This file, represeting the main header file of the Rawsock library, should be included in your project everytime you want to use the library to simplify and enhance the use of Linux raw sockets. It supports, as of now, IPv4 and UDP.</p>
<dl class="section version"><dt>Version</dt><dd>0.3.4 </dd></dl>
<dl class="section date"><dt>Date</dt><dd>2020-01-24 </dd></dl>
<dl class="section copyright"><dt>Copyright</dt><dd>Licensed under GPLv2 </dd></dl>

<p>Definition in file <a class="el" href="rawsock_8h_source.html">rawsock.h</a>.</p>
</div><h2 class="groupheader">Macro Definition Documentation</h2>
<a class="anchor" id="a340376f4c1c554ce0ed8a56353245f87"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define BASIC_IHL&#160;&#160;&#160;5</td>
        </tr>
      </table>
</div><div class="memdoc">
<p><b>IPv4 constant</b>: basic Internet Header Length, without any options. </p>

<p>Definition at line <a class="el" href="rawsock_8h_source.html#l00065">65</a> of file <a class="el" href="rawsock_8h_source.html">rawsock.h</a>.</p>

</div>
</div>
<a class="anchor" id="a6ac68536910e3f9ad37e12294f7aaff0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define BASIC_UDP_TTL&#160;&#160;&#160;64</td>
        </tr>
      </table>
</div><div class="memdoc">
<p><b>IPv4 constant</b>: some sort of "default" TTL which can be used to generate IPv4/UDP packets with a TTL of <em>64</em>. </p>

<p>Definition at line <a class="el" href="rawsock_8h_source.html#l00067">67</a> of file <a class="el" href="rawsock_8h_source.html">rawsock.h</a>.</p>

</div>
</div>
<a class="anchor" id="a9c2ebe239a3b502d61f5ba607a8db4e6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CSUM_IP&#160;&#160;&#160;0x00</td>
        </tr>
      </table>
</div><div class="memdoc">
<p><b>Simple <a class="el" href="rawsock_8h.html#abb14def1a9dd5a7393b77391dddeca13" title="Validate the checksum of a raw &quot;Ethernet&quot; packet, i.e. of any packet containing a struct ether_header...">validateEthCsum()</a> checksum type (<em>csum_t</em>)</b>: compute IPv4 checksum by specifying <em>CSUM_IP</em> as <em>type</em>. </p>

<p>Definition at line <a class="el" href="rawsock_8h_source.html#l00079">79</a> of file <a class="el" href="rawsock_8h_source.html">rawsock.h</a>.</p>

</div>
</div>
<a class="anchor" id="a848a2c02ec2f354018a998c3d87d2836"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CSUM_UDP&#160;&#160;&#160;0x01</td>
        </tr>
      </table>
</div><div class="memdoc">
<p><b>Simple <a class="el" href="rawsock_8h.html#abb14def1a9dd5a7393b77391dddeca13" title="Validate the checksum of a raw &quot;Ethernet&quot; packet, i.e. of any packet containing a struct ether_header...">validateEthCsum()</a> checksum type (<em>csum_t</em>)</b>: compute UDP checksum by specifying <em>CSUM_UDP</em> as <em>type</em>. </p>

<p>Definition at line <a class="el" href="rawsock_8h_source.html#l00080">80</a> of file <a class="el" href="rawsock_8h_source.html">rawsock.h</a>.</p>

</div>
</div>
<a class="anchor" id="aa5815136097e443a0a41d35d9c1d5389"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CSUM_UDPIP&#160;&#160;&#160;0x80</td>
        </tr>
      </table>
</div><div class="memdoc">
<p><b>Combined <a class="el" href="rawsock_8h.html#abb14def1a9dd5a7393b77391dddeca13" title="Validate the checksum of a raw &quot;Ethernet&quot; packet, i.e. of any packet containing a struct ether_header...">validateEthCsum()</a> checksum type (<em>csum_t</em>)</b>: compute IPv4 and UDP checksums by specifying <em>CSUM_UDPIP</em> as <em>type</em>. </p><dl class="section warning"><dt>Warning</dt><dd>If you are extending the library and you want to add another combined type, always use a value from 0x81 to 0xFF, as 0x00 to 0x7F should be simple types, and 0x80 to 0xFF combined ones, to keep things clear. </dd></dl>

<p>Definition at line <a class="el" href="rawsock_8h_source.html#l00081">81</a> of file <a class="el" href="rawsock_8h_source.html">rawsock.h</a>.</p>

</div>
</div>
<a class="anchor" id="afb4547c3913540def3246e79da5e8e01"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ERR_IPHEAD_NOSRCADDR&#160;&#160;&#160;-11</td>
        </tr>
      </table>
</div><div class="memdoc">
<p><b><a class="el" href="rawsock_8h.html#a166eb0daab0e332b134c1dff449a9271">IP4headPopulate*()</a> error definition</b>: unable to retrieve current device IP address. </p>

<p>Definition at line <a class="el" href="rawsock_8h_source.html#l00040">40</a> of file <a class="el" href="rawsock_8h_source.html">rawsock.h</a>.</p>

</div>
</div>
<a class="anchor" id="ab5030ae5a9bf30b1f2c4ee41081bdcc2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ERR_IPHEAD_SOCK&#160;&#160;&#160;-10</td>
        </tr>
      </table>
</div><div class="memdoc">
<p><b><a class="el" href="rawsock_8h.html#a166eb0daab0e332b134c1dff449a9271">IP4headPopulate*()</a> error definition</b>: internal socket creation error. </p>

<p>Definition at line <a class="el" href="rawsock_8h_source.html#l00039">39</a> of file <a class="el" href="rawsock_8h_source.html">rawsock.h</a>.</p>

</div>
</div>
<a class="anchor" id="a29814c440e4009d26f00f2073988f503"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ERR_VIFPRINTER_GETIFADDRS&#160;&#160;&#160;-21</td>
        </tr>
      </table>
</div><div class="memdoc">
<p><b><a class="el" href="rawsock_8h.html#aad9c02628ca1d54590c3bececec86b57" title="Print information about available interfaces. ">vifPrinter()</a> error definition</b>: getifaddrs() (to obtain interfaces list) error. </p>

<p>Definition at line <a class="el" href="rawsock_8h_source.html#l00043">43</a> of file <a class="el" href="rawsock_8h_source.html">rawsock.h</a>.</p>

</div>
</div>
<a class="anchor" id="a4d04863a699cd0ba36a4bad72f87875b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ERR_VIFPRINTER_SOCK&#160;&#160;&#160;-20</td>
        </tr>
      </table>
</div><div class="memdoc">
<p><b><a class="el" href="rawsock_8h.html#aad9c02628ca1d54590c3bececec86b57" title="Print information about available interfaces. ">vifPrinter()</a> error definition</b>: socket creation error. </p>

<p>Definition at line <a class="el" href="rawsock_8h_source.html#l00042">42</a> of file <a class="el" href="rawsock_8h_source.html">rawsock.h</a>.</p>

</div>
</div>
<a class="anchor" id="a21e778534653ff83888669f1d6606a5f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ERR_WLAN_GETIFADDRS&#160;&#160;&#160;-2</td>
        </tr>
      </table>
</div><div class="memdoc">
<p><b><a class="el" href="rawsock_8h.html#a67042209a2494ae4c50c5e4317888226" title="Automatically look for available WLAN, non-WLAN or loopback interfaces. ">wlanLookup()</a> error definition</b>: getifaddrs() (to obtain interfaces list) error. </p>

<p>Definition at line <a class="el" href="rawsock_8h_source.html#l00033">33</a> of file <a class="el" href="rawsock_8h_source.html">rawsock.h</a>.</p>

</div>
</div>
<a class="anchor" id="a93ff51a7c2a9b546fd2453e2132ee133"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ERR_WLAN_GETIFINDEX&#160;&#160;&#160;-5</td>
        </tr>
      </table>
</div><div class="memdoc">
<p><b><a class="el" href="rawsock_8h.html#a67042209a2494ae4c50c5e4317888226" title="Automatically look for available WLAN, non-WLAN or loopback interfaces. ">wlanLookup()</a> error definition</b>: unable to get source interface index (if requested). </p>

<p>Definition at line <a class="el" href="rawsock_8h_source.html#l00036">36</a> of file <a class="el" href="rawsock_8h_source.html">rawsock.h</a>.</p>

</div>
</div>
<a class="anchor" id="aa18e60a5bdd3f8649877c4921b08c050"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ERR_WLAN_GETSRCIP&#160;&#160;&#160;-6</td>
        </tr>
      </table>
</div><div class="memdoc">
<p><b><a class="el" href="rawsock_8h.html#a67042209a2494ae4c50c5e4317888226" title="Automatically look for available WLAN, non-WLAN or loopback interfaces. ">wlanLookup()</a> error definition</b>: unable to get source interface index (if requested). </p>

<p>Definition at line <a class="el" href="rawsock_8h_source.html#l00037">37</a> of file <a class="el" href="rawsock_8h_source.html">rawsock.h</a>.</p>

</div>
</div>
<a class="anchor" id="aaefa4462ab0b860b6bd0bbfc22d5cd33"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ERR_WLAN_GETSRCMAC&#160;&#160;&#160;-4</td>
        </tr>
      </table>
</div><div class="memdoc">
<p><b><a class="el" href="rawsock_8h.html#a67042209a2494ae4c50c5e4317888226" title="Automatically look for available WLAN, non-WLAN or loopback interfaces. ">wlanLookup()</a> error definition</b>: unable to get source MAC address (if requested). </p>

<p>Definition at line <a class="el" href="rawsock_8h_source.html#l00035">35</a> of file <a class="el" href="rawsock_8h_source.html">rawsock.h</a>.</p>

</div>
</div>
<a class="anchor" id="a298bd4822ba623995ce6d17e44dcdb6a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ERR_WLAN_INDEX&#160;&#160;&#160;-3</td>
        </tr>
      </table>
</div><div class="memdoc">
<p><b><a class="el" href="rawsock_8h.html#a67042209a2494ae4c50c5e4317888226" title="Automatically look for available WLAN, non-WLAN or loopback interfaces. ">wlanLookup()</a> error definition</b>: wrong index specified. </p>

<p>Definition at line <a class="el" href="rawsock_8h_source.html#l00034">34</a> of file <a class="el" href="rawsock_8h_source.html">rawsock.h</a>.</p>

</div>
</div>
<a class="anchor" id="ad6423a4df1e8aed89332dfdf9b6436cb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ERR_WLAN_NOIF&#160;&#160;&#160;0</td>
        </tr>
      </table>
</div><div class="memdoc">
<p><b><a class="el" href="rawsock_8h.html#a67042209a2494ae4c50c5e4317888226" title="Automatically look for available WLAN, non-WLAN or loopback interfaces. ">wlanLookup()</a> error definition</b>: no WLAN interfaces found. </p>

<p>Definition at line <a class="el" href="rawsock_8h_source.html#l00031">31</a> of file <a class="el" href="rawsock_8h_source.html">rawsock.h</a>.</p>

</div>
</div>
<a class="anchor" id="a52922b300bbc95f471c2cde6e9213a2c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ERR_WLAN_SOCK&#160;&#160;&#160;-1</td>
        </tr>
      </table>
</div><div class="memdoc">
<p><b><a class="el" href="rawsock_8h.html#a67042209a2494ae4c50c5e4317888226" title="Automatically look for available WLAN, non-WLAN or loopback interfaces. ">wlanLookup()</a> error definition</b>: socket creation error. </p>

<p>Definition at line <a class="el" href="rawsock_8h_source.html#l00032">32</a> of file <a class="el" href="rawsock_8h_source.html">rawsock.h</a>.</p>

</div>
</div>
<a class="anchor" id="a6fe57c8dc5a044a3a1fdfae20ccc8bad"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ETH_IP_UDP_PACKET_SIZE</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">data</td><td>)</td>
          <td>&#160;&#160;&#160;sizeof(struct ether_header)+sizeof(struct iphdr)+sizeof(struct udphdr)+sizeof(data)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p><b>Size definition</b>: given <em>data</em>, as any variable, the IPv4 + UDP payload size (with basic IHL, i.e. no options), <b>including struct ether_header</b>, containing the specified <em>data</em> is calculated and returned in <em>bytes</em>. </p>

<p>Definition at line <a class="el" href="rawsock_8h_source.html#l00094">94</a> of file <a class="el" href="rawsock_8h_source.html">rawsock.h</a>.</p>

</div>
</div>
<a class="anchor" id="a66f2e41ccb093addf0db42970af74b42"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ETH_IP_UDP_PACKET_SIZE_S</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">size</td><td>)</td>
          <td>&#160;&#160;&#160;sizeof(struct ether_header)+sizeof(struct iphdr)+sizeof(struct udphdr)+size</td>
        </tr>
      </table>
</div><div class="memdoc">
<p><b>Size definition</b>: given <em>size</em>, in <em>bytes</em>, the IPv4 + UDP payload size (with basic IHL, i.e. no options), <b>including struct ether_header</b>, containing a payload with the specified <em>size</em> is calculated and returned in <em>bytes</em>. </p>

<p>Definition at line <a class="el" href="rawsock_8h_source.html#l00098">98</a> of file <a class="el" href="rawsock_8h_source.html">rawsock.h</a>.</p>

</div>
</div>
<a class="anchor" id="aa87616dfe8685a4b5f240c19846fe22e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ETHERTYPE_GEONET&#160;&#160;&#160;0x8947</td>
        </tr>
      </table>
</div><div class="memdoc">
<p><b>Additional EtherType definition</b>: GeoNetworking, as defined in ETSI EN 302 636-4-1. </p>

<p>Definition at line <a class="el" href="rawsock_8h_source.html#l00058">58</a> of file <a class="el" href="rawsock_8h_source.html">rawsock.h</a>.</p>

</div>
</div>
<a class="anchor" id="a1c5a3ec926358ac4b8fcd91cf32d9601"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ETHERTYPE_WSMP&#160;&#160;&#160;0x88DC</td>
        </tr>
      </table>
</div><div class="memdoc">
<p><b>Additional EtherType definition</b>: WAVE Short Message Protocol, as defined in IEEE Std 1609.3-2016. </p>

<p>Definition at line <a class="el" href="rawsock_8h_source.html#l00059">59</a> of file <a class="el" href="rawsock_8h_source.html">rawsock.h</a>.</p>

</div>
</div>
<a class="anchor" id="a078b5997c266ca75d55abbad2d8d7462"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FLAG_MOREFRAG_MASK&#160;&#160;&#160;(1&lt;&lt;5)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p><b>IPv4 flags mask</b>: Mask to set the <em>More Fragments</em> (MF) IPv4 flag, in the <a class="el" href="rawsock_8h.html#a166eb0daab0e332b134c1dff449a9271">flags</a> argument of <a class="el" href="rawsock_8h.html#a166eb0daab0e332b134c1dff449a9271">IP4headPopulate*()</a> </p><dl class="section note"><dt>Note</dt><dd>It can be OR-ed with other masks. </dd></dl>

<p>Definition at line <a class="el" href="rawsock_8h_source.html#l00075">75</a> of file <a class="el" href="rawsock_8h_source.html">rawsock.h</a>.</p>

</div>
</div>
<a class="anchor" id="a5483704d4c1b6c832db99ffe700b1345"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FLAG_NOFRAG_MASK&#160;&#160;&#160;(1&lt;&lt;6)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p><b>IPv4 flags mask</b>: Mask to set the <em>Don't Fragment</em> (DF) IPv4 flag, in the <a class="el" href="rawsock_8h.html#a166eb0daab0e332b134c1dff449a9271">flags</a> argument of <a class="el" href="rawsock_8h.html#a166eb0daab0e332b134c1dff449a9271">IP4headPopulate*()</a> </p><dl class="section note"><dt>Note</dt><dd>It can be OR-ed with other masks. </dd></dl>

<p>Definition at line <a class="el" href="rawsock_8h_source.html#l00073">73</a> of file <a class="el" href="rawsock_8h_source.html">rawsock.h</a>.</p>

</div>
</div>
<a class="anchor" id="a3d605dd366ed60554963ef178a7787ad"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FLAG_RESERVED_MASK&#160;&#160;&#160;(1&lt;&lt;7)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p><b>IPv4 flags mask</b>: Mask to set the <em>Reserved</em> IPv4 flag, in the <a class="el" href="rawsock_8h.html#a166eb0daab0e332b134c1dff449a9271">flags</a> argument of <a class="el" href="rawsock_8h.html#a166eb0daab0e332b134c1dff449a9271">IP4headPopulate*()</a> </p><dl class="section note"><dt>Note</dt><dd>It can be OR-ed with other masks. </dd></dl>

<p>Definition at line <a class="el" href="rawsock_8h_source.html#l00074">74</a> of file <a class="el" href="rawsock_8h_source.html">rawsock.h</a>.</p>

</div>
</div>
<a class="anchor" id="af556407e9c582f485d45f219df9cfc1f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define IP_UDP_PACKET_SIZE</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">data</td><td>)</td>
          <td>&#160;&#160;&#160;sizeof(struct iphdr)+sizeof(struct udphdr)+sizeof(data)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p><b>Size definition</b>: given <em>data</em>, as any variable, the IPv4 + UDP payload size (with basic IHL, i.e. no options) containing the specified <em>data</em> is calculated and returned in <em>bytes</em>. </p>

<p>Definition at line <a class="el" href="rawsock_8h_source.html#l00093">93</a> of file <a class="el" href="rawsock_8h_source.html">rawsock.h</a>.</p>

</div>
</div>
<a class="anchor" id="af223f5e314af4eabc6d66cc8ee02a3a0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define IP_UDP_PACKET_SIZE_S</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">size</td><td>)</td>
          <td>&#160;&#160;&#160;sizeof(struct iphdr)+sizeof(struct udphdr)+size</td>
        </tr>
      </table>
</div><div class="memdoc">
<p><b>Size definition</b>: given <em>size</em>, in <em>bytes</em>, the IPv4 + UDP payload size (with basic IHL, i.e. no options) containing a payload with the specified <em>size</em> is calculated and returned in <em>bytes</em>. </p>

<p>Definition at line <a class="el" href="rawsock_8h_source.html#l00097">97</a> of file <a class="el" href="rawsock_8h_source.html">rawsock.h</a>.</p>

</div>
</div>
<a class="anchor" id="ae3d82b086c0b0e4ddac202078f01f120"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define IPV4&#160;&#160;&#160;4</td>
        </tr>
      </table>
</div><div class="memdoc">
<p><b>IPv4 constant</b>: basic Internet Header Length, in <em>bytes</em> without any options. </p>

<p>Definition at line <a class="el" href="rawsock_8h_source.html#l00066">66</a> of file <a class="el" href="rawsock_8h_source.html">rawsock.h</a>.</p>

</div>
</div>
<a class="anchor" id="ae01dbae885bc8abecb82bd865515c081"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MAC_ADDR_SIZE&#160;&#160;&#160;6</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Size of a MAC address, in <em>bytes</em>. You can use this definition to declare your own <em>uint8_t</em>, <em>unsigned char</em> or <em>byte_t</em> array, with <em>MAC_ADDR_SIZE</em> elements, to store any MAC address. For instance: <code>uint8_t macaddress[MAC_ADDR_SIZE];</code> </p>

<p>Definition at line <a class="el" href="rawsock_8h_source.html#l00028">28</a> of file <a class="el" href="rawsock_8h_source.html">rawsock.h</a>.</p>

</div>
</div>
<a class="anchor" id="ad085edcd01bf33b3ac926fd440ff5faf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MAC_BROADCAST&#160;&#160;&#160;0x01</td>
        </tr>
      </table>
</div><div class="memdoc">
<p><b>MAC type definition (managed by <a class="el" href="rawsock_8h.html#af9ffe247a4f65a16e4bf123104e8105e" title="Prepare a macaddr_t variable. ">prepareMacAddrT()</a>, <a class="el" href="rawsock_8h.html#af86e3c8e9300732f7222fcce3b08adad" title="Get the MAC address type. ">macAddrTypeGet()</a> and <a class="el" href="rawsock_8h.html#aed9676022fd046d34e243cf52cfd8255" title="Free a macaddr_t variable. ">freeMacAddrT()</a>)</b>: broadcast (FF:FF:FF:FF:FF:FF) MAC address. </p>

<p>Definition at line <a class="el" href="rawsock_8h_source.html#l00051">51</a> of file <a class="el" href="rawsock_8h_source.html">rawsock.h</a>.</p>

</div>
</div>
<a class="anchor" id="ac7b68a1e0ffd7ae30f3848d1bd582837"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MAC_FILE_PATH_SIZE&#160;&#160;&#160;23</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reserved for future use. </p>

<p>Definition at line <a class="el" href="rawsock_8h_source.html#l00027">27</a> of file <a class="el" href="rawsock_8h_source.html">rawsock.h</a>.</p>

</div>
</div>
<a class="anchor" id="ac0e8fb4c350b55365bc0fd1b5d79574c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MAC_MULTICAST&#160;&#160;&#160;0x03</td>
        </tr>
      </table>
</div><div class="memdoc">
<p><b>MAC type definition (managed by <a class="el" href="rawsock_8h.html#af9ffe247a4f65a16e4bf123104e8105e" title="Prepare a macaddr_t variable. ">prepareMacAddrT()</a>, <a class="el" href="rawsock_8h.html#af86e3c8e9300732f7222fcce3b08adad" title="Get the MAC address type. ">macAddrTypeGet()</a> and <a class="el" href="rawsock_8h.html#aed9676022fd046d34e243cf52cfd8255" title="Free a macaddr_t variable. ">freeMacAddrT()</a>)</b>: multicast (01:<em>xx</em>:<em>xx</em>:<em>xx</em>:<em>xx</em>:<em>xx</em>) MAC address. </p>

<p>Definition at line <a class="el" href="rawsock_8h_source.html#l00053">53</a> of file <a class="el" href="rawsock_8h_source.html">rawsock.h</a>.</p>

</div>
</div>
<a class="anchor" id="addf164de7bf1717f1fea7fc8c131df8c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MAC_NULL&#160;&#160;&#160;0x00</td>
        </tr>
      </table>
</div><div class="memdoc">
<p><b>MAC type definition (managed by <a class="el" href="rawsock_8h.html#af9ffe247a4f65a16e4bf123104e8105e" title="Prepare a macaddr_t variable. ">prepareMacAddrT()</a>, <a class="el" href="rawsock_8h.html#af86e3c8e9300732f7222fcce3b08adad" title="Get the MAC address type. ">macAddrTypeGet()</a> and <a class="el" href="rawsock_8h.html#aed9676022fd046d34e243cf52cfd8255" title="Free a macaddr_t variable. ">freeMacAddrT()</a>)</b>: NULL MAC-address (NULL pointer returned). </p>

<p>Definition at line <a class="el" href="rawsock_8h_source.html#l00050">50</a> of file <a class="el" href="rawsock_8h_source.html">rawsock.h</a>.</p>

</div>
</div>
<a class="anchor" id="a5f6afdfc5a1697437de7c81eec02881a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MAC_PRINTER</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">mac_array</td><td>)</td>
          <td>&#160;&#160;&#160;mac_array[0], mac_array[1], mac_array[2], mac_array[3], mac_array[4], mac_array[5]</td>
        </tr>
      </table>
</div><div class="memdoc">
<p><em>MAC_PRINTER(address-variable)</em> should be used in combination with <a class="el" href="rawsock_8h.html#adc14ca0cde20d80e340db369d21aa9b9">PRI_MAC</a> to specify the variable containing the MAC address. For instance, if <em>addr</em> is a variable of type <a class="el" href="rawsock_8h.html#a7516f6c5689b1c204b2bb4f05b09e1cf">macaddr_t</a>, it is possible to print the corresponding address with <code>printf("Address: " PRI_MAC "\\n",<a class="el" href="rawsock_8h.html#a5f6afdfc5a1697437de7c81eec02881a">MAC_PRINTER(addr)</a>)</code>. </p><dl class="section warning"><dt>Warning</dt><dd>No check is performed to ensure that a NULL pointer (<a class="el" href="rawsock_8h.html#addf164de7bf1717f1fea7fc8c131df8c">MAC_NULL</a>) is not passed to <em>MAC_PRINTER</em>. The check must be manually performed to avoid a segmentation fault. </dd></dl>

<p>Definition at line <a class="el" href="rawsock_8h_source.html#l00085">85</a> of file <a class="el" href="rawsock_8h_source.html">rawsock.h</a>.</p>

</div>
</div>
<a class="anchor" id="a8809fd8c4ef6f730bcc908229f08a072"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MAC_SCANNER</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">mac_array</td><td>)</td>
          <td>&#160;&#160;&#160;&amp;mac_array[0], &amp;mac_array[1], &amp;mac_array[2], &amp;mac_array[3], &amp;mac_array[4], &amp;mac_array[5]</td>
        </tr>
      </table>
</div><div class="memdoc">
<p><em>MAC_SCANNER(<em>address-variable</em>)</em> should be used in combination with <a class="el" href="rawsock_8h.html#ac9b222932e933c2a3dac81ed9aeb8ded">SCN_MAC</a> to specify the variable containing the MAC address (without <code>&amp;</code>, as it is already added by <em>MAC_SCANNER</em>). For instance, if <em>addr</em> is an allocated variable of type <a class="el" href="rawsock_8h.html#a7516f6c5689b1c204b2bb4f05b09e1cf">macaddr_t</a>, it is possible to store an address inside <em>addr</em> with <code>scanf(SCN_MAC,MAC_SCANNER(addr))</code>. </p><dl class="section warning"><dt>Warning</dt><dd>No check is performed to ensure that a NULL pointer (<a class="el" href="rawsock_8h.html#addf164de7bf1717f1fea7fc8c131df8c">MAC_NULL</a>) is not passed to <em>MAC_SCANNER</em>. The check must be manually performed to avoid a segmentation fault (the variable should be already allocated with <a class="el" href="rawsock_8h.html#af9ffe247a4f65a16e4bf123104e8105e" title="Prepare a macaddr_t variable. ">prepareMacAddrT()</a>). </dd></dl>

<p>Definition at line <a class="el" href="rawsock_8h_source.html#l00089">89</a> of file <a class="el" href="rawsock_8h_source.html">rawsock.h</a>.</p>

</div>
</div>
<a class="anchor" id="aa97ac5e7eaefc0ee2f00af097bf2ce62"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MAC_UNICAST&#160;&#160;&#160;0x02</td>
        </tr>
      </table>
</div><div class="memdoc">
<p><b>MAC type definition (managed by <a class="el" href="rawsock_8h.html#af9ffe247a4f65a16e4bf123104e8105e" title="Prepare a macaddr_t variable. ">prepareMacAddrT()</a>, <a class="el" href="rawsock_8h.html#af86e3c8e9300732f7222fcce3b08adad" title="Get the MAC address type. ">macAddrTypeGet()</a> and <a class="el" href="rawsock_8h.html#aed9676022fd046d34e243cf52cfd8255" title="Free a macaddr_t variable. ">freeMacAddrT()</a>)</b>: unicast MAC address. </p>

<p>Definition at line <a class="el" href="rawsock_8h_source.html#l00052">52</a> of file <a class="el" href="rawsock_8h_source.html">rawsock.h</a>.</p>

</div>
</div>
<a class="anchor" id="a7b505fc6e4743303fac564fe419e11be"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MAC_ZERO&#160;&#160;&#160;0x04</td>
        </tr>
      </table>
</div><div class="memdoc">
<p><b>MAC type definition (managed by <a class="el" href="rawsock_8h.html#af9ffe247a4f65a16e4bf123104e8105e" title="Prepare a macaddr_t variable. ">prepareMacAddrT()</a>, <a class="el" href="rawsock_8h.html#af86e3c8e9300732f7222fcce3b08adad" title="Get the MAC address type. ">macAddrTypeGet()</a> and <a class="el" href="rawsock_8h.html#aed9676022fd046d34e243cf52cfd8255" title="Free a macaddr_t variable. ">freeMacAddrT()</a>)</b>: all-zero (00:00:00:00:00:00) MAC address (no MAC is set). </p>

<p>Definition at line <a class="el" href="rawsock_8h_source.html#l00054">54</a> of file <a class="el" href="rawsock_8h_source.html">rawsock.h</a>.</p>

</div>
</div>
<a class="anchor" id="adc14ca0cde20d80e340db369d21aa9b9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PRI_MAC&#160;&#160;&#160;&quot;%02x:%02x:%02x:%02x:%02x:%02x&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Useful macro specifier for printing MAC addresses inside the <em>printf()</em> familty of functions. <em>PRI_MAC</em> works as a single specifier for the whole address, like PRIu<em>xx</em> in <em>inttypes.h</em> for printing <em>xx</em> bits integers, but without the leading <code>%</code>. See also the strictly related <a class="el" href="rawsock_8h.html#a5f6afdfc5a1697437de7c81eec02881a">MAC_PRINTER</a> macro. </p>

<p>Definition at line <a class="el" href="rawsock_8h_source.html#l00084">84</a> of file <a class="el" href="rawsock_8h_source.html">rawsock.h</a>.</p>

</div>
</div>
<a class="anchor" id="ac9b222932e933c2a3dac81ed9aeb8ded"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SCN_MAC&#160;&#160;&#160;&quot;%x:%x:%x:%x:%x:%x%*c&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Useful macro specifier for reading MAC addresses inside the <em>scanf()</em> familty of functions. <em>SCN_MAC</em> works as a single specifier for the whole address, like SCNu<em>xx</em> in <em>inttypes.h</em> for reading <em>xx</em> bits integers, but without the leading <code>%</code>. See also the strictly related <a class="el" href="rawsock_8h.html#a8809fd8c4ef6f730bcc908229f08a072">MAC_SCANNER</a> macro. </p>

<p>Definition at line <a class="el" href="rawsock_8h_source.html#l00088">88</a> of file <a class="el" href="rawsock_8h_source.html">rawsock.h</a>.</p>

</div>
</div>
<a class="anchor" id="acbbb2b8b10ab4740a9f6c62b93cfef66"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define UDP_PACKET_SIZE</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">data</td><td>)</td>
          <td>&#160;&#160;&#160;sizeof(struct udphdr)+sizeof(data)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p><b>Size definition</b>: given <em>data</em>, as any variable, the UDP payload size containing the specified <em>data</em> is calculated and returned in <em>bytes</em>. </p>

<p>Definition at line <a class="el" href="rawsock_8h_source.html#l00092">92</a> of file <a class="el" href="rawsock_8h_source.html">rawsock.h</a>.</p>

</div>
</div>
<a class="anchor" id="a20da24fd44ae674c4d8373e58685c573"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define UDP_PACKET_SIZE_S</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">size</td><td>)</td>
          <td>&#160;&#160;&#160;sizeof(struct udphdr)+size</td>
        </tr>
      </table>
</div><div class="memdoc">
<p><b>Size definition</b>: given <em>size</em>, in <em>bytes</em>, the UDP payload size containing a payload with the specified <em>size</em> is calculated and returned in <em>bytes</em>. </p>

<p>Definition at line <a class="el" href="rawsock_8h_source.html#l00096">96</a> of file <a class="el" href="rawsock_8h_source.html">rawsock.h</a>.</p>

</div>
</div>
<a class="anchor" id="a179d15dbd6876292449c2b92d61e35f7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define UDPHEADERLEN&#160;&#160;&#160;8</td>
        </tr>
      </table>
</div><div class="memdoc">
<p><b>UDP constant</b>: number of bytes inside the UDP header. </p>

<p>Definition at line <a class="el" href="rawsock_8h_source.html#l00070">70</a> of file <a class="el" href="rawsock_8h_source.html">rawsock.h</a>.</p>

</div>
</div>
<a class="anchor" id="aff64daee24d50575c816c5d75874d001"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define WLANLOOKUP_LOOPBACK&#160;&#160;&#160;-1</td>
        </tr>
      </table>
</div><div class="memdoc">
<p><b><a class="el" href="rawsock_8h.html#a67042209a2494ae4c50c5e4317888226" title="Automatically look for available WLAN, non-WLAN or loopback interfaces. ">wlanLookup()</a> special <a class="el" href="rawsock_8h.html#a67042209a2494ae4c50c5e4317888226">index</a> value definition</b>: use <em>WLANLOOKUP_LOOPBACK</em> to search for loopback IF instead of WLAN IF. </p>

<p>Definition at line <a class="el" href="rawsock_8h_source.html#l00062">62</a> of file <a class="el" href="rawsock_8h_source.html">rawsock.h</a>.</p>

</div>
</div>
<a class="anchor" id="a8a4daab19d5e118e848deaa847b17646"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define WLANLOOKUP_NONWLAN&#160;&#160;&#160;1</td>
        </tr>
      </table>
</div><div class="memdoc">
<p><b><a class="el" href="rawsock_8h.html#a67042209a2494ae4c50c5e4317888226" title="Automatically look for available WLAN, non-WLAN or loopback interfaces. ">wlanLookup()</a> mode definition</b>: look for non-wireless interfaces only. </p>

<p>Definition at line <a class="el" href="rawsock_8h_source.html#l00047">47</a> of file <a class="el" href="rawsock_8h_source.html">rawsock.h</a>.</p>

</div>
</div>
<a class="anchor" id="aa13ccea41ef8a2be5418a024491ab3cb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define WLANLOOKUP_WLAN&#160;&#160;&#160;0</td>
        </tr>
      </table>
</div><div class="memdoc">
<p><b><a class="el" href="rawsock_8h.html#a67042209a2494ae4c50c5e4317888226" title="Automatically look for available WLAN, non-WLAN or loopback interfaces. ">wlanLookup()</a> mode definition</b>: look for wireless interfaces only. </p>

<p>Definition at line <a class="el" href="rawsock_8h_source.html#l00046">46</a> of file <a class="el" href="rawsock_8h_source.html">rawsock.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a class="anchor" id="a0661d7d1353e0bca70c64563f635b034"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef uint8_t <a class="el" href="rawsock_8h.html#a0661d7d1353e0bca70c64563f635b034">byte_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Custom type to store a single byte. It should be defined only if it was not defined elsewhere. </p>

<p>Definition at line <a class="el" href="rawsock_8h_source.html#l00102">102</a> of file <a class="el" href="rawsock_8h_source.html">rawsock.h</a>.</p>

</div>
</div>
<a class="anchor" id="a71cbed2832d72fff127aa670c21cd79b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef __sum16 <a class="el" href="rawsock_8h.html#a71cbed2832d72fff127aa670c21cd79b">csum16_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Custom type to store checksums (it may be a bit clearer that using directly <em>__sum16</em>, although <em>__sum16</em> is perfectly fine too). </p>

<p>Definition at line <a class="el" href="rawsock_8h_source.html#l00109">109</a> of file <a class="el" href="rawsock_8h_source.html">rawsock.h</a>.</p>

</div>
</div>
<a class="anchor" id="aa2241201dc140b721a522eaf39d9e527"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef unsigned char <a class="el" href="rawsock_8h.html#aa2241201dc140b721a522eaf39d9e527">csumt_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Custom type to store checksum types to be passed to <a class="el" href="rawsock_8h.html#abb14def1a9dd5a7393b77391dddeca13" title="Validate the checksum of a raw &quot;Ethernet&quot; packet, i.e. of any packet containing a struct ether_header...">validateEthCsum()</a>. </p>

<p>Definition at line <a class="el" href="rawsock_8h_source.html#l00108">108</a> of file <a class="el" href="rawsock_8h_source.html">rawsock.h</a>.</p>

</div>
</div>
<a class="anchor" id="a23bd834253bb70c8f0f64c79aed350b9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef unsigned short <a class="el" href="rawsock_8h.html#a23bd834253bb70c8f0f64c79aed350b9">ethertype_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Custom type which can be used to store the <em>EtherType</em>. </p>

<p>Definition at line <a class="el" href="rawsock_8h_source.html#l00106">106</a> of file <a class="el" href="rawsock_8h_source.html">rawsock.h</a>.</p>

</div>
</div>
<a class="anchor" id="a7516f6c5689b1c204b2bb4f05b09e1cf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef uint8_t* <a class="el" href="rawsock_8h.html#a7516f6c5689b1c204b2bb4f05b09e1cf">macaddr_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Custom type to store a MAC address. It is better and should be managed with the provided <a class="el" href="rawsock_8h.html#af9ffe247a4f65a16e4bf123104e8105e" title="Prepare a macaddr_t variable. ">prepareMacAddrT()</a>, <a class="el" href="rawsock_8h.html#af86e3c8e9300732f7222fcce3b08adad" title="Get the MAC address type. ">macAddrTypeGet()</a> and <a class="el" href="rawsock_8h.html#aed9676022fd046d34e243cf52cfd8255" title="Free a macaddr_t variable. ">freeMacAddrT()</a> functions, to avoid messing up with pointer. </p>

<p>Definition at line <a class="el" href="rawsock_8h_source.html#l00105">105</a> of file <a class="el" href="rawsock_8h_source.html">rawsock.h</a>.</p>

</div>
</div>
<a class="anchor" id="a69f2206781eb90dcf48b8be85a62f900"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int <a class="el" href="rawsock_8h.html#a69f2206781eb90dcf48b8be85a62f900">rawsockerr_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Custom type to store errors returned by the library functions. </p>

<p>Definition at line <a class="el" href="rawsock_8h_source.html#l00107">107</a> of file <a class="el" href="rawsock_8h_source.html">rawsock.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a class="anchor" id="a91e19fa4fff461493e1a41f7c7aa4e5f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="rawsock_8h.html#a91e19fa4fff461493e1a41f7c7aa4e5f">protocol_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Protocol type enumerator. </p>
<p>Protocol type enumerator, useful to manage more than one protocol on a single program. As more protocols will be supported, this <em>enum</em> will be updated accordingly. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="a91e19fa4fff461493e1a41f7c7aa4e5fa0e207f13266615a67248e0872a857e22"></a>UNSET_P&#160;</td><td class="fielddoc">
<p>Unspecified protocol type </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a91e19fa4fff461493e1a41f7c7aa4e5fadb542475cf9d0636e4225e216cee9ae6"></a>UDP&#160;</td><td class="fielddoc">
<p>UDP over IPv4 </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a91e19fa4fff461493e1a41f7c7aa4e5faab84bdffa9f13502c4a851f15c80a90c"></a>AMQP_0_9&#160;</td><td class="fielddoc">
<p>AMQP 0.9 (RabbitMQ) - not yet supported by the library </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a91e19fa4fff461493e1a41f7c7aa4e5fa99b2d1c97e1d5b77bc8038106a70c053"></a>AMQP_1_0&#160;</td><td class="fielddoc">
<p>AMQP 1.0 (ActiveMQ) - not yet supported by the library </p>
</td></tr>
</table>

<p>Definition at line <a class="el" href="rawsock_8h_source.html#l00125">125</a> of file <a class="el" href="rawsock_8h_source.html">rawsock.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="a1ca9119d2c4568914340756b5dbeb7ce"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void display_packet </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>text</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="rawsock_8h.html#a0661d7d1353e0bca70c64563f635b034">byte_t</a> *&#160;</td>
          <td class="paramname"><em>packet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Display packet in hexadecimal form. </p>
<p>This function can be used to display a packet content in hexadecimal form, given the pointer to a buffer of <a class="el" href="rawsock_8h.html#a0661d7d1353e0bca70c64563f635b034">bytes</a> and its length (<em>len</em>).</p>
<p><em>text</em> can be used to specify an additional text that will be printer before printing the actual packet content.</p>
<dl class="section note"><dt>Note</dt><dd><em>stdout</em> is always used to print the requested information.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">text</td><td>Additional text preceding the packet content </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">packet</td><td>Buffer containing the whole packet to be printed </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>Length, in bytes, of the buffer to be printed (i.e. number of elements of the <a class="el" href="rawsock_8h.html#a0661d7d1353e0bca70c64563f635b034">bytes</a> buffer to be printed)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None. </dd></dl>

<p>Definition at line <a class="el" href="rawsock_8c_source.html#l00459">459</a> of file <a class="el" href="rawsock_8c_source.html">rawsock.c</a>.</p>

</div>
</div>
<a class="anchor" id="a42af111446f0e87c3e72e1cba60d3a24"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void display_packetc </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>text</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="rawsock_8h.html#a0661d7d1353e0bca70c64563f635b034">byte_t</a> *&#160;</td>
          <td class="paramname"><em>packet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Display packet in character form. </p>
<p>This function can be used to display a packet content in character form, given the pointer to a buffer of <a class="el" href="rawsock_8h.html#a0661d7d1353e0bca70c64563f635b034">bytes</a> and its length (<em>len</em>).</p>
<p><em>text</em> can be used to specify an additional text that will be printer before printing the actual packet content.</p>
<dl class="section note"><dt>Note</dt><dd><em>stdout</em> is always used to print the requested information.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">text</td><td>Additional text preceding the packet content </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">packet</td><td>Buffer containing the whole packet to be printed </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>Length, in bytes, of the buffer to be printed (i.e. number of elements of the <a class="el" href="rawsock_8h.html#a0661d7d1353e0bca70c64563f635b034">bytes</a> buffer to be printed)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None. </dd></dl>

<p>Definition at line <a class="el" href="rawsock_8c_source.html#l00487">487</a> of file <a class="el" href="rawsock_8c_source.html">rawsock.c</a>.</p>

</div>
</div>
<a class="anchor" id="a3551ee96011895ab6e895381782cb138"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t etherEncapsulate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="rawsock_8h.html#a0661d7d1353e0bca70c64563f635b034">byte_t</a> *&#160;</td>
          <td class="paramname"><em>packet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct ether_header *&#160;</td>
          <td class="paramname"><em>header</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="rawsock_8h.html#a0661d7d1353e0bca70c64563f635b034">byte_t</a> *&#160;</td>
          <td class="paramname"><em>sdu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>sdusize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Combine Ethernet SDU and PCI. </p>
<p>This function combines an Ethernet SDU and PCI, the latter in the form of a <em>struct ether_header</em> Linux structure.</p>
<p>The user shall specify a buffer in which the full packet will be put, the ethernet header, the SDU (<em>byte_t *sdu</em>) and its size in bytes.</p>
<dl class="section warning"><dt>Warning</dt><dd>The <em>packet</em> buffer should be already allocated, and it should be big enough to contain both the header <b>and</b> the SDU. It is possible to use the macros defined in <a class="el" href="rawsock_8h.html">rawsock.h</a>, such as <a class="el" href="rawsock_8h.html#a66f2e41ccb093addf0db42970af74b42">ETH_IP_UDP_PACKET_SIZE_S(udp_payload_size)</a>, to find the required size starting from an higher layer payload size and then call a <b>malloc()</b> with that size to allocate the memory for <em>packet</em>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">packet</td><td>Packet buffer (should be already allocated) that will contain the full packet (SDU+PCI). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">header</td><td>Ethernet header, as <em>struct ether_header</em>. Should be filled in with <a class="el" href="rawsock_8h.html#ac70b54da68a91bb811cf57d2c27381fd">etherheadPopulate*()</a> before being passed to this function. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sdu</td><td>Buffer containing the SDU. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sdusize</td><td>Size, in <em>bytes</em>, of the SDU.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The full packet size (SDU+PCI), in <em>bytes</em>, is returned. </dd></dl>

<p>Definition at line <a class="el" href="rawsock_8c_source.html#l00612">612</a> of file <a class="el" href="rawsock_8c_source.html">rawsock.c</a>.</p>

</div>
</div>
<a class="anchor" id="ac70b54da68a91bb811cf57d2c27381fd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void etherheadPopulate </td>
          <td>(</td>
          <td class="paramtype">struct ether_header *&#160;</td>
          <td class="paramname"><em>etherHeader</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="rawsock_8h.html#a7516f6c5689b1c204b2bb4f05b09e1cf">macaddr_t</a>&#160;</td>
          <td class="paramname"><em>macsrc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="rawsock_8h.html#a7516f6c5689b1c204b2bb4f05b09e1cf">macaddr_t</a>&#160;</td>
          <td class="paramname"><em>macdst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="rawsock_8h.html#a23bd834253bb70c8f0f64c79aed350b9">ethertype_t</a>&#160;</td>
          <td class="paramname"><em>type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Populate Ethernet header. </p>
<p>This function can be used to populate an ethernet header (<em>struct ether_header</em>).</p>
<p>A variant, <a class="el" href="rawsock_8h.html#a6dda4611a853da42435df9a025266641" title="Populate broadcast Ethernet header (variant of etherheadPopulate()) ">etherheadPopulateB()</a>, addressed specifically to broadcast transmissions, exists.</p>
<p>The user shall specify the pointer to an already existing <em>ether_header</em> structure to be filled in, the source and destination MAC addresses and the EtherType (either one type in <b>net/ethernet.h</b> or one type in <a class="el" href="rawsock_8h.html">rawsock.h</a>).</p>
<dl class="section note"><dt>Note</dt><dd>Like all the other functions inside this library, it already takes care of byte ordering.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>All the parameters passed to this function should be in <b>host</b> byte order, i.e. the "normal" one for the application.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">etherHeader</td><td>Pointer to the Ethernet header structure, used in raw sockets (for instance, to send data over a <em>ETH_P_ALL</em> socket). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">macsrc</td><td><a class="el" href="rawsock_8h.html#a7516f6c5689b1c204b2bb4f05b09e1cf">macaddr_t</a> variable containing the source MAC address. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">macdst</td><td><a class="el" href="rawsock_8h.html#a7516f6c5689b1c204b2bb4f05b09e1cf">macaddr_t</a> variable containing the destination MAC address. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">type</td><td><a class="el" href="rawsock_8h.html#a23bd834253bb70c8f0f64c79aed350b9">ethertype_t</a> variable containing the EtherType.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None. </dd></dl>

<p>Definition at line <a class="el" href="rawsock_8c_source.html#l00587">587</a> of file <a class="el" href="rawsock_8c_source.html">rawsock.c</a>.</p>

</div>
</div>
<a class="anchor" id="a6dda4611a853da42435df9a025266641"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void etherheadPopulateB </td>
          <td>(</td>
          <td class="paramtype">struct ether_header *&#160;</td>
          <td class="paramname"><em>etherHeader</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="rawsock_8h.html#a7516f6c5689b1c204b2bb4f05b09e1cf">macaddr_t</a>&#160;</td>
          <td class="paramname"><em>mac</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="rawsock_8h.html#a23bd834253bb70c8f0f64c79aed350b9">ethertype_t</a>&#160;</td>
          <td class="paramname"><em>type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Populate broadcast Ethernet header (variant of <a class="el" href="rawsock_8h.html#ac70b54da68a91bb811cf57d2c27381fd" title="Populate Ethernet header. ">etherheadPopulate()</a>) </p>
<p>This function can be used to populate an ethernet header (<em>struct ether_header</em>) for broadcast transmissions (i.e. a broadcast MAC address is automatically inserted).</p>
<p>The user shall specify the pointer to an already existing <em>ether_header</em> structure to be filled in, the source MAC and the EtherType (either one type in <b>net/ethernet.h</b> or one type in <a class="el" href="rawsock_8h.html">rawsock.h</a>).</p>
<dl class="section note"><dt>Note</dt><dd>Like all the other functions inside this library, it already takes care of byte ordering.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>All the parameters passed to this function should be in <b>host</b> byte order, i.e. the "normal" one for the application.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">etherHeader</td><td>Pointer to the Ethernet header structure, used in raw sockets (for instance, to send data over a <em>ETH_P_ALL</em> socket). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mac</td><td><a class="el" href="rawsock_8h.html#a7516f6c5689b1c204b2bb4f05b09e1cf">macaddr_t</a> variable containing the source MAC address. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">type</td><td><a class="el" href="rawsock_8h.html#a23bd834253bb70c8f0f64c79aed350b9">ethertype_t</a> variable containing the EtherType.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None. </dd></dl>

<p>Definition at line <a class="el" href="rawsock_8c_source.html#l00556">556</a> of file <a class="el" href="rawsock_8c_source.html">rawsock.c</a>.</p>

</div>
</div>
<a class="anchor" id="aed9676022fd046d34e243cf52cfd8255"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void freeMacAddrT </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="rawsock_8h.html#a7516f6c5689b1c204b2bb4f05b09e1cf">macaddr_t</a>&#160;</td>
          <td class="paramname"><em>mac</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Free a <em>macaddr_t</em> variable. </p>
<p>Frees a previously allocated MAC address variable (<em>macaddr_t</em>).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mac</td><td>A previously allocated <a class="el" href="rawsock_8h.html#a7516f6c5689b1c204b2bb4f05b09e1cf">macaddr_t</a> variable/pointer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None. </dd></dl>

<p>Definition at line <a class="el" href="rawsock_8c_source.html#l00078">78</a> of file <a class="el" href="rawsock_8c_source.html">rawsock.c</a>.</p>

</div>
</div>
<a class="anchor" id="a14ac66b8c5b58a37f5cbfabec68e317c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void getSrcMAC </td>
          <td>(</td>
          <td class="paramtype">struct ether_header *&#160;</td>
          <td class="paramname"><em>etherHeader</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="rawsock_8h.html#a7516f6c5689b1c204b2bb4f05b09e1cf">macaddr_t</a>&#160;</td>
          <td class="paramname"><em>macsrc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve source MAC address field from Ethernet header. </p>
<p>Simple function to retrieve the source MAC address field from a <em>struct ether_header</em>, and copy it inside the <em>macsrc</em> variable.</p>
<dl class="section warning"><dt>Warning</dt><dd>Always be sure to pass a non-NULL <em>macsrc</em> to this function. In any case, if a NULL <em>macsrc</em> is passed, the function simply does nothing.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">etherHeader</td><td><em>struct ether_header</em>, already filled in or extracted from a received packet. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">macsrc</td><td>Source MAC address, filled in by the function. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="rawsock_8c_source.html#l00633">633</a> of file <a class="el" href="rawsock_8c_source.html">rawsock.c</a>.</p>

</div>
</div>
<a class="anchor" id="a02a011504fe087e9d13aff96a26017c7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t hton64 </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>hostu64</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert a 64-bit unsigned value between host and network byte order. </p>
<p>This function works like <a href="https://linux.die.net/man/3/htons">htons()</a> and <a href="https://linux.die.net/man/3/htonl">htonl()</a>, but with 64-bit unsigned integers (i.e. <em>uint64_t</em>).</p>
<dl class="section note"><dt>Note</dt><dd><em>uint64_t</em> is defined inside <em>stdint.h</em> and <em>inttypes.h</em>.</dd>
<dd>
This function has no direct utility in IPv4/UDP packet management, but it can be used to manage any custom or non-custom 64 bit data field to be sent over the network.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">hostu64</td><td>Host byte order integer to be converted into network byte order</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>64-bit unsigned value value converted to network byte order </dd></dl>

<p>Definition at line <a class="el" href="rawsock_8c_source.html#l00513">513</a> of file <a class="el" href="rawsock_8c_source.html">rawsock.c</a>.</p>

</div>
</div>
<a class="anchor" id="a5117600ef5b7603bd169e16a4d305bfa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t IP4Encapsulate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="rawsock_8h.html#a0661d7d1353e0bca70c64563f635b034">byte_t</a> *&#160;</td>
          <td class="paramname"><em>packet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct iphdr *&#160;</td>
          <td class="paramname"><em>header</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="rawsock_8h.html#a0661d7d1353e0bca70c64563f635b034">byte_t</a> *&#160;</td>
          <td class="paramname"><em>sdu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>sdusize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Combine IPv4 SDU and PCI. </p>
<p>This function combines an IPv4 SDU and PCI, the latter in the form of a <em>struct iphdr</em> Linux structure.</p>
<p>The user shall specify a buffer in which the full packet will be put, the IPv4 header, the SDU (<em>byte_t *sdu</em>) and its size in bytes.</p>
<dl class="section warning"><dt>Warning</dt><dd>The <em>packet</em> buffer should be already allocated, and it should be big enough to contain both the header <b>and</b> the SDU. It is possible to use the macros defined in <a class="el" href="rawsock_8h.html">rawsock.h</a>, such as <a class="el" href="rawsock_8h.html#af223f5e314af4eabc6d66cc8ee02a3a0">IP_UDP_PACKET_SIZE_S(udp_payload_size)</a>, to find the required size starting from an higher layer payload size and then call a <b>malloc()</b> with that size to allocate the memory for <em>packet</em>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">packet</td><td>Packet buffer (should be already allocated) that will contain the full IPv4 packet (SDU+PCI). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">header</td><td>IPv4 header, as <em>struct iphdr</em>. Should be filled in with <a class="el" href="rawsock_8h.html#a166eb0daab0e332b134c1dff449a9271">IP4headPopulate*()</a> before being passed to this function. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sdu</td><td>Buffer containing the SDU. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sdusize</td><td>Size, in <em>bytes</em>, of the SDU.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The full packet size (SDU+PCI), in <em>bytes</em>, is returned. </dd></dl>

<p>Definition at line <a class="el" href="rawsock_8c_source.html#l00926">926</a> of file <a class="el" href="rawsock_8c_source.html">rawsock.c</a>.</p>

</div>
</div>
<a class="anchor" id="a30db7ab77625aba3abe06ae33c892715"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IP4headAddID </td>
          <td>(</td>
          <td class="paramtype">struct iphdr *&#160;</td>
          <td class="paramname"><em>IPhead</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned short&#160;</td>
          <td class="paramname"><em>id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add ID to a given IPv4 header. </p>
<p>Since it can be useful, after preparing a certain header, to update quite often the IPv4 ID (depending on the application and on the use case, though), this function allows to perform the aformentioned operation, inserting a given <em>id</em> inside an already populated IPv4 header (<em>IPhead</em>).</p>
<dl class="section note"><dt>Note</dt><dd>Since <a class="el" href="rawsock_8h.html#a166eb0daab0e332b134c1dff449a9271" title="Populate IP version 4 header. ">IP4headPopulate()</a> and its variants only initialize the identification field to <code>0</code>, a call to this function is required to set a specific ID inside an IPv4 header, before sending any packet over raw sockets.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">IPhead</td><td>IPv4 header structure (<em>struct iphdr</em>) in which the ID field has to be set. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>16-bit IP identification value</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None. </dd></dl>

<p>Definition at line <a class="el" href="rawsock_8c_source.html#l00886">886</a> of file <a class="el" href="rawsock_8c_source.html">rawsock.c</a>.</p>

</div>
</div>
<a class="anchor" id="aeea7cc65afcd15945e6be31ec0a7f136"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IP4headAddTotLen </td>
          <td>(</td>
          <td class="paramtype">struct iphdr *&#160;</td>
          <td class="paramname"><em>IPhead</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned short&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add Total Length to a given IPv4 header. </p>
<p>This function can be used to force a certain length of the entire packet inside the IPv4 header <em>Total Length</em> field.</p>
<dl class="section note"><dt>Note</dt><dd>This function should be used only if, for any reason, the packet to be sent will not be processed by <a class="el" href="rawsock_8h.html#a5117600ef5b7603bd169e16a4d305bfa" title="Combine IPv4 SDU and PCI. ">IP4Encapsulate()</a>. In all the other cases, when combining the IPv4 SDU and PCI with <a class="el" href="rawsock_8h.html#a5117600ef5b7603bd169e16a4d305bfa" title="Combine IPv4 SDU and PCI. ">IP4Encapsulate()</a> the <em>Total Length</em> field should be automatically set by the aforementioned function.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">IPhead</td><td>IPv4 header structure (<em>struct iphdr</em>) in which the <em>Total Length</em> field has to be set. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>Length, in <em>bytes</em>, to be inserted inside the IPv4 header.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None. </dd></dl>

<p>Definition at line <a class="el" href="rawsock_8c_source.html#l00904">904</a> of file <a class="el" href="rawsock_8c_source.html">rawsock.c</a>.</p>

</div>
</div>
<a class="anchor" id="a166eb0daab0e332b134c1dff449a9271"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="rawsock_8h.html#a69f2206781eb90dcf48b8be85a62f900">rawsockerr_t</a> IP4headPopulate </td>
          <td>(</td>
          <td class="paramtype">struct iphdr *&#160;</td>
          <td class="paramname"><em>IPhead</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>devname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>destIP</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char&#160;</td>
          <td class="paramname"><em>tos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned short&#160;</td>
          <td class="paramname"><em>frag_offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char&#160;</td>
          <td class="paramname"><em>ttl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char&#160;</td>
          <td class="paramname"><em>protocol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structipaddrs.html">ipaddrs</a> *&#160;</td>
          <td class="paramname"><em>addrs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Populate IP version 4 header. </p>
<p>This function can be used to populate an Ipv4 header (<em>struct iphdr</em>).</p>
<p>Two variants exist:</p><ul>
<li><a class="el" href="rawsock_8h.html#acbddc8a0001b2c08908f266d3436e3f0" title="Populate IP version 4 header with struct in_addr addresses (variant of IP4headPopulate()) ...">IP4headPopulateS()</a>, to specify a <em>struct in_addr</em> destination IP address instead of a human-readable string</li>
<li><a class="el" href="rawsock_8h.html#ae696dee7a0ca07e0872c7e56595e5553" title="Populate broadcast IP version 4 header (variant of IP4headPopulate()) ">IP4headPopulateB()</a>, to populate an IPv4 header for broadcast transmissions (a broadcast destination IP address is automatically inserted)</li>
</ul>
<p>The user shall specify an already existing IP header structure to be filled in, the interface name inside <em>devname</em> (for instance <em>wlan0</em>), the destination IP address as a human-readable string (e.g. <code>"192.168.1.180"</code>), the TOS value, the fragment offset value, the TTL, the protocol and the IP header flags (reserved, DF, MF).</p>
<p>If <em>struct ipaddrs *addrs</em> is non-NULL, this function, other than returning possible errors (<a class="el" href="rawsock_8h.html#ab5030ae5a9bf30b1f2c4ee41081bdcc2">ERR_IPHEAD_SOCK</a> or <a class="el" href="rawsock_8h.html#afb4547c3913540def3246e79da5e8e01">ERR_IPHEAD_NOSRCADDR</a>) as return value, fills the structure pointed by <em>addrs</em> with the destination and source IP addresses.</p>
<dl class="section note"><dt>Note</dt><dd>Like all the other functions inside this library, it already takes care of byte ordering.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>All the parameters passed to this function should be in <b>host</b> byte order, i.e. the "normal" one for the application.</dd>
<dd>
This function does <b>not</b> fill the ID field: an additional call to <a class="el" href="rawsock_8h.html#a30db7ab77625aba3abe06ae33c892715" title="Add ID to a given IPv4 header. ">IP4headAddID()</a> is required if you do not want to send a packet with <b>0</b> ID, for which, instead, it is not necessary to call <a class="el" href="rawsock_8h.html#a30db7ab77625aba3abe06ae33c892715" title="Add ID to a given IPv4 header. ">IP4headAddID()</a>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">IPhead</td><td>Pointer to the IPv4 header structure, used in raw sockets. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">devname</td><td>Name of the interface which will be used to send the packet (it is used to automatically retrieve the source IP address) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">destIP</td><td>Destination IP address, a string containing the address in a human-readable format. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tos</td><td>Type of Service (ToS) field. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">frag_offset</td><td>IPv4 fragment offset field. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ttl</td><td>Time To Live (TTL) field. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">protocol</td><td>Higher layer protocol field. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">flags</td><td>IPv4 flags (reserved, DF, MF): should be filled in using the macros: <a class="el" href="rawsock_8h.html#a5483704d4c1b6c832db99ffe700b1345">FLAG_NOFRAG_MASK</a>, <a class="el" href="rawsock_8h.html#a3d605dd366ed60554963ef178a7787ad">FLAG_RESERVED_MASK</a> and <a class="el" href="rawsock_8h.html#a078b5997c266ca75d55abbad2d8d7462">FLAG_MOREFRAG_MASK</a>. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">addrs</td><td>Pointer to the <a class="el" href="structipaddrs.html">ipaddrs</a> structure to be filled in with the destination and source IP addresses, or NULL if no structure has to be filled in.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><b>0</b> if the header was filled in properly, or, in case of error, a <a class="el" href="rawsock_8h.html#a69f2206781eb90dcf48b8be85a62f900">rawsockerr_t</a> error:<ul>
<li><em>ERR_IPHEAD_SOCK</em> -&gt; internal socket creation error: unable to set source IP address inside the header</li>
<li><em>ERR_IPHEAD_NOSRCADDR</em> -&gt; cannot retrieve the source IP address to be inserted inside the header </li>
</ul>
</dd></dl>

<p>Definition at line <a class="el" href="rawsock_8c_source.html#l00678">678</a> of file <a class="el" href="rawsock_8c_source.html">rawsock.c</a>.</p>

</div>
</div>
<a class="anchor" id="ae696dee7a0ca07e0872c7e56595e5553"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="rawsock_8h.html#a69f2206781eb90dcf48b8be85a62f900">rawsockerr_t</a> IP4headPopulateB </td>
          <td>(</td>
          <td class="paramtype">struct iphdr *&#160;</td>
          <td class="paramname"><em>IPhead</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>devname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char&#160;</td>
          <td class="paramname"><em>tos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned short&#160;</td>
          <td class="paramname"><em>frag_offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char&#160;</td>
          <td class="paramname"><em>ttl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char&#160;</td>
          <td class="paramname"><em>protocol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structipaddrs.html">ipaddrs</a> *&#160;</td>
          <td class="paramname"><em>addrs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Populate broadcast IP version 4 header (variant of <a class="el" href="rawsock_8h.html#a166eb0daab0e332b134c1dff449a9271" title="Populate IP version 4 header. ">IP4headPopulate()</a>) </p>
<p>This function can be used to populate an IPv4 header (<em>struct iphdr</em>) for broadcast transmissions.</p>
<p>The user shall specify an already existing IP header structure to be filled in, the interface name inside <em>devname</em> (for instance <em>wlan0</em>), the TOS value, the fragment offset value, the TTL, the protocol and the IP header flags (reserved, DF, MF).</p>
<p>A broadcast destination IP address is automatically inserted (i.e. <em>255.255.255.255</em>).</p>
<p>If <em>struct ipaddrs *addrs</em> is non-NULL, this function, other than returning possible errors (<a class="el" href="rawsock_8h.html#ab5030ae5a9bf30b1f2c4ee41081bdcc2">ERR_IPHEAD_SOCK</a> or <a class="el" href="rawsock_8h.html#afb4547c3913540def3246e79da5e8e01">ERR_IPHEAD_NOSRCADDR</a>) as return value, fills the structure pointed by <em>addrs</em> with the destination and source IP addresses.</p>
<dl class="section note"><dt>Note</dt><dd>Like all the other functions inside this library, it already takes care of byte ordering.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>All the parameters passed to this function should be in <b>host</b> byte order, i.e. the "normal" one for the application.</dd>
<dd>
This function does <b>not</b> fill the ID field: an additional call to <a class="el" href="rawsock_8h.html#a30db7ab77625aba3abe06ae33c892715" title="Add ID to a given IPv4 header. ">IP4headAddID()</a> is required if you do not want to send a packet with <b>0</b> ID, for which, instead, it is not necessary to call <a class="el" href="rawsock_8h.html#a30db7ab77625aba3abe06ae33c892715" title="Add ID to a given IPv4 header. ">IP4headAddID()</a>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">IPhead</td><td>Pointer to the IPv4 header structure, used in raw sockets. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">devname</td><td>Name of the interface which will be used to send the packet (it is used to automatically retrieve the source IP address) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tos</td><td>Type of Service (ToS) field. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">frag_offset</td><td>IPv4 fragment offset field. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ttl</td><td>Time To Live (TTL) field. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">protocol</td><td>Higher layer protocol field. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">flags</td><td>IPv4 flags (reserved, DF, MF): should be filled in using the macros: <a class="el" href="rawsock_8h.html#a5483704d4c1b6c832db99ffe700b1345">FLAG_NOFRAG_MASK</a>, <a class="el" href="rawsock_8h.html#a3d605dd366ed60554963ef178a7787ad">FLAG_RESERVED_MASK</a> and <a class="el" href="rawsock_8h.html#a078b5997c266ca75d55abbad2d8d7462">FLAG_MOREFRAG_MASK</a>. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">addrs</td><td>Pointer to the <a class="el" href="structipaddrs.html">ipaddrs</a> structure to be filled in with the destination and source IP addresses, or NULL if no structure has to be filled in.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><b>0</b> if the header was filled in properly, or, in case of error, a <a class="el" href="rawsock_8h.html#a69f2206781eb90dcf48b8be85a62f900">rawsockerr_t</a> error:<ul>
<li><em>ERR_IPHEAD_SOCK</em> -&gt; internal socket creation error: unable to set source IP address inside the header</li>
<li><em>ERR_IPHEAD_NOSRCADDR</em> -&gt; cannot retrieve the source IP address to be inserted inside the header </li>
</ul>
</dd></dl>

<p>Definition at line <a class="el" href="rawsock_8c_source.html#l00830">830</a> of file <a class="el" href="rawsock_8c_source.html">rawsock.c</a>.</p>

</div>
</div>
<a class="anchor" id="acbddc8a0001b2c08908f266d3436e3f0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="rawsock_8h.html#a69f2206781eb90dcf48b8be85a62f900">rawsockerr_t</a> IP4headPopulateS </td>
          <td>(</td>
          <td class="paramtype">struct iphdr *&#160;</td>
          <td class="paramname"><em>IPhead</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>devname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct in_addr&#160;</td>
          <td class="paramname"><em>destIP</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char&#160;</td>
          <td class="paramname"><em>tos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned short&#160;</td>
          <td class="paramname"><em>frag_offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char&#160;</td>
          <td class="paramname"><em>ttl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char&#160;</td>
          <td class="paramname"><em>protocol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structipaddrs.html">ipaddrs</a> *&#160;</td>
          <td class="paramname"><em>addrs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Populate IP version 4 header with <em>struct in_addr</em> addresses (variant of <a class="el" href="rawsock_8h.html#a166eb0daab0e332b134c1dff449a9271" title="Populate IP version 4 header. ">IP4headPopulate()</a>) </p>
<p>This function can be used to populate an IPv4 header (<em>struct iphdr</em>).</p>
<p>The user shall specify an already existing IP header structure to be filled in, the interface name inside <em>devname</em> (for instance <em>wlan0</em>), the destination IP address, stored inside a <em>struct in_addr</em>, the TOS value, the fragment offset value, the TTL, the protocol and the IP header flags (reserved, DF, MF).</p>
<p>If <em>struct ipaddrs *addrs</em> is non-NULL, this function, other than returning possible errors (<a class="el" href="rawsock_8h.html#ab5030ae5a9bf30b1f2c4ee41081bdcc2">ERR_IPHEAD_SOCK</a> or <a class="el" href="rawsock_8h.html#afb4547c3913540def3246e79da5e8e01">ERR_IPHEAD_NOSRCADDR</a>) as return value, fills the structure pointed by <em>addrs</em> with the destination and source IP addresses.</p>
<dl class="section note"><dt>Note</dt><dd>Like all the other functions inside this library, it already takes care of byte ordering.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>All the parameters passed to this function should be in <b>host</b> byte order, i.e. the "normal" one for the application.</dd>
<dd>
This function does <b>not</b> fill the ID field: an additional call to <a class="el" href="rawsock_8h.html#a30db7ab77625aba3abe06ae33c892715" title="Add ID to a given IPv4 header. ">IP4headAddID()</a> is required if you do not want to send a packet with <b>0</b> ID, for which, instead, it is not necessary to call <a class="el" href="rawsock_8h.html#a30db7ab77625aba3abe06ae33c892715" title="Add ID to a given IPv4 header. ">IP4headAddID()</a>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">IPhead</td><td>Pointer to the IPv4 header structure, used in raw sockets. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">devname</td><td>Name of the interface which will be used to send the packet (it is used to automatically retrieve the source IP address) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">destIP</td><td>Destination IP address, stored inside the <em>s_addr</em> field of the specified <em>struct in_addr</em>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tos</td><td>Type of Service (ToS) field. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">frag_offset</td><td>IPv4 fragment offset field. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ttl</td><td>Time To Live (TTL) field. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">protocol</td><td>Higher layer protocol field. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">flags</td><td>IPv4 flags (reserved, DF, MF): should be filled in using the macros: <a class="el" href="rawsock_8h.html#a5483704d4c1b6c832db99ffe700b1345">FLAG_NOFRAG_MASK</a>, <a class="el" href="rawsock_8h.html#a3d605dd366ed60554963ef178a7787ad">FLAG_RESERVED_MASK</a> and <a class="el" href="rawsock_8h.html#a078b5997c266ca75d55abbad2d8d7462">FLAG_MOREFRAG_MASK</a>. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">addrs</td><td>Pointer to the <a class="el" href="structipaddrs.html">ipaddrs</a> structure to be filled in with the destination and source IP addresses, or NULL if no structure has to be filled in.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><b>0</b> if the header was filled in properly, or, in case of error, a <a class="el" href="rawsock_8h.html#a69f2206781eb90dcf48b8be85a62f900">rawsockerr_t</a> error:<ul>
<li><em>ERR_IPHEAD_SOCK</em> -&gt; internal socket creation error: unable to set source IP address inside the header</li>
<li><em>ERR_IPHEAD_NOSRCADDR</em> -&gt; cannot retrieve the source IP address to be inserted inside the header </li>
</ul>
</dd></dl>

<p>Definition at line <a class="el" href="rawsock_8c_source.html#l00755">755</a> of file <a class="el" href="rawsock_8c_source.html">rawsock.c</a>.</p>

</div>
</div>
<a class="anchor" id="af86e3c8e9300732f7222fcce3b08adad"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int macAddrTypeGet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="rawsock_8h.html#a7516f6c5689b1c204b2bb4f05b09e1cf">macaddr_t</a>&#160;</td>
          <td class="paramname"><em>mac</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the MAC address type. </p>
<p>Starting from a MAC address type, its type is returned (unicast, multicast, broadcast).</p>
<dl class="section warning"><dt>Warning</dt><dd>As soon as a new MAC address is allocated, its type is set to the equivalent of <em>MAC_NULL</em> (i.e. a <em>NULL</em> pointer). You can use this to check if an address was properly allocated, by calling <code>if(macAddrTypeGet(mac)!=MAC_NULL)</code>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mac</td><td>A previously allocated <a class="el" href="rawsock_8h.html#a7516f6c5689b1c204b2bb4f05b09e1cf">macaddr_t</a> variable/pointer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The MAC address tupe is returned: either <a class="el" href="rawsock_8h.html#addf164de7bf1717f1fea7fc8c131df8c">MAC_NULL</a>, <a class="el" href="rawsock_8h.html#aa97ac5e7eaefc0ee2f00af097bf2ce62">MAC_UNICAST</a>, <a class="el" href="rawsock_8h.html#ac0e8fb4c350b55365bc0fd1b5d79574c">MAC_MULTICAST</a>, <a class="el" href="rawsock_8h.html#ad085edcd01bf33b3ac926fd440ff5faf">MAC_BROADCAST</a> or <a class="el" href="rawsock_8h.html#a7b505fc6e4743303fac564fe419e11be">MAC_ZERO</a>. They are all threated as <em>unsigned int</em>. </dd></dl>

<p>Definition at line <a class="el" href="rawsock_8c_source.html#l00096">96</a> of file <a class="el" href="rawsock_8c_source.html">rawsock.c</a>.</p>

</div>
</div>
<a class="anchor" id="a452c0159838860279d7f195c96ca01f2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t ntoh64 </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>netu64</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert a 64-bit unsigned value between network and host byte order. </p>
<p>This function works like <a href="https://linux.die.net/man/3/ntohs">ntohs()</a> and <a href="https://linux.die.net/man/3/ntohl">ntohl()</a>, but with 64-bit unsigned integers (i.e. <em>uint64_t</em>).</p>
<dl class="section note"><dt>Note</dt><dd><em>uint64_t</em> is defined inside <em>stdint.h</em> and <em>inttypes.h</em>.</dd>
<dd>
This function has no direct utility in IPv4/UDP packet management, but it can be used to manage any custom or non-custom 64 bit data field to be sent over the network.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">netu64</td><td>Network byte order integer to be converted into host byte order</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>64-bit unsigned value value converted to host byte order </dd></dl>

<p>Definition at line <a class="el" href="rawsock_8c_source.html#l00532">532</a> of file <a class="el" href="rawsock_8c_source.html">rawsock.c</a>.</p>

</div>
</div>
<a class="anchor" id="af9ffe247a4f65a16e4bf123104e8105e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="rawsock_8h.html#a7516f6c5689b1c204b2bb4f05b09e1cf">macaddr_t</a> prepareMacAddrT </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prepare a <em>macaddr_t</em> variable. </p>
<p>Allocates a six element byte array to store any MAC address, using the <em>macaddr_t</em> custom type.</p>
<dl class="section warning"><dt>Warning</dt><dd>Every MAC address allocated with this function is initialized to FF:FF:FF:FF:FF:FF.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>It returns the pointer to the allocated MAC address, in the form of a <a class="el" href="rawsock_8h.html#a7516f6c5689b1c204b2bb4f05b09e1cf">macaddr_t</a> custom type. <a class="el" href="rawsock_8h.html#addf164de7bf1717f1fea7fc8c131df8c">MAC_NULL</a> is returned if it was not possibile to allocate the required memory. </dd></dl>

<p>Definition at line <a class="el" href="rawsock_8c_source.html#l00054">54</a> of file <a class="el" href="rawsock_8c_source.html">rawsock.c</a>.</p>

</div>
</div>
<a class="anchor" id="af596c860215789d5a99e419fa69a0500"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rs_printerror </td>
          <td>(</td>
          <td class="paramtype">FILE *&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="rawsock_8h.html#a69f2206781eb90dcf48b8be85a62f900">rawsockerr_t</a>&#160;</td>
          <td class="paramname"><em>code</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Print more detailed error messages. </p>
<p>Given a stream (e.g. <em>stdout</em> or <em>stderr</em>) and the error code, as a <a class="el" href="rawsock_8h.html#a69f2206781eb90dcf48b8be85a62f900">rawsockerr_t</a> type, more detailed information is printed on the selected stream.</p>
<p>This function essentialy works like <em>perror()</em>, but instead of describing the current value of <em>errno</em>, it describes what is stored inside <em>code</em>.</p>
<p>It can be useful to print any error that may occur after a call to <a class="el" href="rawsock_8h.html#a67042209a2494ae4c50c5e4317888226" title="Automatically look for available WLAN, non-WLAN or loopback interfaces. ">wlanLookup()</a> or other compatible library functions.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">stream</td><td><em>FILE</em> stream to be used to print the requested error (it can be a file, <em>stdout</em> or <em>stderr</em>). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">code</td><td><a class="el" href="rawsock_8h.html#a69f2206781eb90dcf48b8be85a62f900">rawsockerr_t</a> integer variable containing the error code (returned by another library function).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None. </dd></dl>

<p>Definition at line <a class="el" href="rawsock_8c_source.html#l00399">399</a> of file <a class="el" href="rawsock_8c_source.html">rawsock.c</a>.</p>

</div>
</div>
<a class="anchor" id="a40bb53171777fd6d4ade834c512519c5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void test_injectIPCsumError </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="rawsock_8h.html#a0661d7d1353e0bca70c64563f635b034">byte_t</a> *&#160;</td>
          <td class="paramname"><em>IPpacket</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Test function: inject a checksum error in an IP packet. </p>
<p>This function can be used as a test function to specifically force a checksum error inside an already formed IP packet.</p>
<p>The pointer to the full IP packet shall be passed (IP header+payload).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">IPpacket</td><td>Pointer to a <a class="el" href="rawsock_8h.html#a0661d7d1353e0bca70c64563f635b034">byte_t</a> buffer containing the full IP packet.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None. </dd></dl>

<p>Definition at line <a class="el" href="rawsock_8c_source.html#l01185">1185</a> of file <a class="el" href="rawsock_8c_source.html">rawsock.c</a>.</p>

</div>
</div>
<a class="anchor" id="aa2a34461395e274047f3c605b0aa16b4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void test_injectUDPCsumError </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="rawsock_8h.html#a0661d7d1353e0bca70c64563f635b034">byte_t</a> *&#160;</td>
          <td class="paramname"><em>UDPpacket</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Test function: inject a checksum error in an UDP packet. </p>
<p>This function can be used as a test function to specifically force a checksum error inside an already formed UDP packet.</p>
<p>The pointer to the full UDP packet shall be passed (UDP header+payload - <b>not</b> including neither the Ethernet header nor the IPv4 one)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">UDPpacket</td><td>Pointer to a <a class="el" href="rawsock_8h.html#a0661d7d1353e0bca70c64563f635b034">byte_t</a> buffer containing the full UDP packet.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None. </dd></dl>

<p>Definition at line <a class="el" href="rawsock_8c_source.html#l01211">1211</a> of file <a class="el" href="rawsock_8c_source.html">rawsock.c</a>.</p>

</div>
</div>
<a class="anchor" id="af66696d8e4ee2eb7d09a1eed9497b452"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t UDPencapsulate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="rawsock_8h.html#a0661d7d1353e0bca70c64563f635b034">byte_t</a> *&#160;</td>
          <td class="paramname"><em>packet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct udphdr *&#160;</td>
          <td class="paramname"><em>header</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="rawsock_8h.html#a0661d7d1353e0bca70c64563f635b034">byte_t</a> *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>payloadsize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structipaddrs.html">ipaddrs</a>&#160;</td>
          <td class="paramname"><em>addrs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Combine UDP payload and header. </p>
<p>This function combines a UDP payload and header, the latter in the form of a <em>struct udphdr</em> Linux structure.</p>
<p>The user shall specify a buffer in which the full packet will be put, the UDP header, the payload (<em>byte_t *data</em>), its size in bytes and a <a class="el" href="structipaddrs.html">struct ipaddrs</a> containing the source and destination IP addresses. In particular, the latter is needed to properly compute the UDP checksum.</p>
<dl class="section warning"><dt>Warning</dt><dd>The <em>packet</em> buffer should be already allocated, and it should be big enough to contain both the header <b>and</b> the payload. It is possible to use the macros defined in <a class="el" href="rawsock_8h.html">rawsock.h</a>, such as <a class="el" href="rawsock_8h.html#a20da24fd44ae674c4d8373e58685c573">UDP_PACKET_SIZE_S(udp_payload_size)</a>, to find the required size starting from an higher layer payload size and then call a <b>malloc()</b> with that size to allocate the memory for <em>packet</em>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">packet</td><td>Packet buffer (should be already allocated) that will contain the full IPv4 packet (SDU+PCI). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">header</td><td>IPv4 header, as <em>struct iphdr</em>. Should be filled in with <a class="el" href="rawsock_8h.html#a166eb0daab0e332b134c1dff449a9271">IP4headPopulate*()</a> before being passed to this function. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>Buffer containing the data payload. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">payloadsize</td><td>Size, in <em>bytes</em>, of the payload.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The full packet size (SDU+PCI), in <em>bytes</em>, is returned. </dd></dl>

<p>Definition at line <a class="el" href="rawsock_8c_source.html#l00988">988</a> of file <a class="el" href="rawsock_8c_source.html">rawsock.c</a>.</p>

</div>
</div>
<a class="anchor" id="a73f90608054cccd554921c8237479aa2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="rawsock_8h.html#a0661d7d1353e0bca70c64563f635b034">byte_t</a>* UDPgetpacketpointers </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="rawsock_8h.html#a0661d7d1353e0bca70c64563f635b034">byte_t</a> *&#160;</td>
          <td class="paramname"><em>pktbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct ether_header **&#160;</td>
          <td class="paramname"><em>etherHeader</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct iphdr **&#160;</td>
          <td class="paramname"><em>IPheader</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct udphdr **&#160;</td>
          <td class="paramname"><em>UDPheader</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get pointers to headers and payload in UDP packet buffer. </p>
<p>This function can be used to obtain, given a certain buffer containing a full UDP packet, the pointers to the headers (i.e. to the <em>struct ether_header</em>, <em>struct iphdr</em> and <em>struct udphdr</em> structure respectively) and payload sections</p>
<p>Example of call: </p><pre class="fragment">payload=UDPgetpacketpointers(packet,&amp;etherHeader,&amp;IPheader,&amp;udpHeader);
</pre><p>with: </p><pre class="fragment">struct ether_header *etherHeader;
struct iphdr *IPheader;
struct udphdr *udpHeader;
byte_t *payload;
</pre><p>If any argument is NULL, no pointer will be returned for that argument.</p>
<dl class="section note"><dt>Note</dt><dd>You can use this function, after receiving a packet, to retrieve header specific data and parse the payload.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>No memory is allocated by this function! It will return pointers inside the original <em>pktbuf</em> buffer, by doing the proper arithmetics.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pktbuf</td><td>Packet buffer, containing a full valid UDP packet (the checksum can be wrong, "valid" means here "that is really UDP"), including <em>struct ether_header</em>. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">etherHeader</td><td>This pointer will be written by the function, storing the pointer to the ethernet header inside the <em>pktbuf</em> packet buffer; as it is written by the function, a pointer to the pointer shall be passed to <a class="el" href="rawsock_8h.html#a73f90608054cccd554921c8237479aa2" title="Get pointers to headers and payload in UDP packet buffer. ">UDPgetpacketpointers()</a> (see the example above) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">IPheader</td><td>This pointer will be written by the function, storing the pointer to the IPv4 header inside the <em>pktbuf</em> packet buffer. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">UDPheader</td><td>This pointer will be written by the function, storing the pointer to the UDP header inside the <em>pktbuf</em> packet buffer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The pointer to the payload (of type <a class="el" href="rawsock_8h.html#a0661d7d1353e0bca70c64563f635b034">byte_t</a>) is returned by the function. If <em>pktbuf</em> is a valid pointer, it should never happen that the returned pointer is NULL. If <em>pktbuf</em> is NULL, NULL will be returned. </dd></dl>

<p>Definition at line <a class="el" href="rawsock_8c_source.html#l01034">1034</a> of file <a class="el" href="rawsock_8c_source.html">rawsock.c</a>.</p>

</div>
</div>
<a class="anchor" id="a64420c632f0fa00e99aa66db3099823f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned short UDPgetpayloadsize </td>
          <td>(</td>
          <td class="paramtype">struct udphdr *&#160;</td>
          <td class="paramname"><em>UDPheader</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get UDP payload size, given a UDP header. </p>
<p>This function can be used to obtain the UDP payload size as <em>unsigned short (int)</em>, given a UDP header pointer.</p>
<p>It basically extracts the length field and substracts the standard header length.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">UDPheader</td><td>Pointer to a <em>struct udphdr</em>, containing the UDP header.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>It returns the length of the payload stored inside the packet corresponding to the UDP header passed as argument. </dd></dl>

<p>Definition at line <a class="el" href="rawsock_8c_source.html#l01060">1060</a> of file <a class="el" href="rawsock_8c_source.html">rawsock.c</a>.</p>

</div>
</div>
<a class="anchor" id="a6eb7d52837b679a35c818cb2cd93a569"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void UDPheadPopulate </td>
          <td>(</td>
          <td class="paramtype">struct udphdr *&#160;</td>
          <td class="paramname"><em>UDPhead</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned short&#160;</td>
          <td class="paramname"><em>sourceport</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned short&#160;</td>
          <td class="paramname"><em>destport</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Populate UDP header. </p>
<p>This function can be used to populate a UDP header (<em>struct udphdr</em>).</p>
<p>The user shall specify an already existing UDP header structure, the source port and the destination port.</p>
<dl class="section warning"><dt>Warning</dt><dd>This function will initialize the checksum field to <b>0</b>. A subsequent call to <a class="el" href="rawsock_8h.html#af66696d8e4ee2eb7d09a1eed9497b452" title="Combine UDP payload and header. ">UDPencapsulate()</a>, specifying the payload you want to insert inside the UDP packet, is needed, since the latter is responsible for properly computing the UDP checksum, which, it may be important to recall, takes into account also the header and pseudo-header.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Like all the other functions inside this library, it already takes care of byte ordering.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">UDPhead</td><td>Pointer to the UDP header structure, used in raw sockets. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sourceport</td><td>Source port (16 bit unsigned value) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">destport</td><td>Destination port (16 bit unsigned value)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None. </dd></dl>

<p>Definition at line <a class="el" href="rawsock_8c_source.html#l00960">960</a> of file <a class="el" href="rawsock_8c_source.html">rawsock.c</a>.</p>

</div>
</div>
<a class="anchor" id="abb14def1a9dd5a7393b77391dddeca13"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool validateEthCsum </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="rawsock_8h.html#a0661d7d1353e0bca70c64563f635b034">byte_t</a> *&#160;</td>
          <td class="paramname"><em>packet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="rawsock_8h.html#a71cbed2832d72fff127aa670c21cd79b">csum16_t</a>&#160;</td>
          <td class="paramname"><em>csum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="rawsock_8h.html#a71cbed2832d72fff127aa670c21cd79b">csum16_t</a> *&#160;</td>
          <td class="paramname"><em>combinedcsum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="rawsock_8h.html#aa2241201dc140b721a522eaf39d9e527">csumt_t</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Validate the checksum of a raw "Ethernet" packet, i.e. of any packet containing a <em>struct ether_header</em> as first bytes. </p>
<p>This function can be used to valide the checksum of any Ethernet raw packet, which can be, for instance, received through a raw socket.</p>
<p>A more detailed description is presented below, in the "Parameters" section.</p>
<dl class="section warning"><dt>Warning</dt><dd>Additional arguments are nedded, as of now, only when the type is <b>CSUM_UDP</b> or <b>CSUM_UDPIP</b>. In that case, you shall pass a pointer to a <em>size_t</em> variable containing the size of the <b>UDP payload</b>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">packet</td><td>Pointer to the <b>full</b> packet buffer for which the checksum has to be validated. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">csum</td><td>Checksum value to be checked against the newly computed value, from <em>packet</em> (see also <a class="el" href="rawsock_8h.html#a71cbed2832d72fff127aa670c21cd79b">csum16_t</a>) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">combinedcsum</td><td>This parameter is a pointer to a checksum value. It should be <b>NULL</b> for non combined checksum types, otherwise it should contain the pointer to the value of the second checksum to be checked (the ordering between <em>csum</em> and _*combinedcsum_ is the same as the one in the checksum type constant - for instance: <b>CSUM_UDPIP</b> requires <em>csum</em> to be related to <b>UDP</b> and _*combinedcsum_ to <b>IPv4</b>). If NULL is specified for any combined type, the function will always return <b>false</b>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">type</td><td>Checksum protocol (see also <a class="el" href="rawsock_8h.html#a71cbed2832d72fff127aa670c21cd79b">csum16_t</a>): various protocols can be specified within the same function, in order to keep it easier to be extended as newer protocols will be implemented inside the library. The supported protocols are defined inside proper "Checksum protocols" constants in <b><a class="el" href="rawsock_8h.html">rawsock.h</a></b>, starting with <b>CSUM_</b> (e.g. <a class="el" href="rawsock_8h.html#a9c2ebe239a3b502d61f5ba607a8db4e6">CSUM_IP</a>). Both simple protocols and combined ones are supported: in the first case, only the checksum related to the specified protocol is checked (<em>csum16_t csum</em>), in the second case, two checksums, contained inside the same packet, are checked (<em>csum16_t csum</em> and <em>csum16_t *combinedcsum</em>). This can be useful, for instance, to check both the UDP and IP checksums all at once; in case a combined mode is selected _*combinedcsum_ shall be non-NULL, otherwise the function will always return <b>false</b>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">args</td><td>Additional protocol-specific arguments: these are typically dependant on the specified protocol. For instance, using IPv4, they are not needed and NULL can be passed; instead, when using UDP (or UDP+IP), they shall contain the pointer to a single value which is the payload length (this may avoid computing it multiple times, outside and inside this function, when a variable containing it is already available). Everytime an additional argument is needed and it is not passed (i.e. NULL <em>args</em>), the function always returns <b>false</b>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Boolean value containing <b>true</b> if the packet contained a valid checksum, <b>false</b> otherwise (or in case of errors). </dd></dl>

<p>Definition at line <a class="el" href="rawsock_8c_source.html#l01099">1099</a> of file <a class="el" href="rawsock_8c_source.html">rawsock.c</a>.</p>

</div>
</div>
<a class="anchor" id="aad9c02628ca1d54590c3bececec86b57"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="rawsock_8h.html#a69f2206781eb90dcf48b8be85a62f900">rawsockerr_t</a> vifPrinter </td>
          <td>(</td>
          <td class="paramtype">FILE *&#160;</td>
          <td class="paramname"><em>stream</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Print information about available interfaces. </p>
<p>This function can be used to automatically print some information about the interfaces which are up and available in the system.</p>
<p>The **"Interface internal index"** value can be used as a reference for the <em>index</em> value to be inserted in <a class="el" href="rawsock_8h.html#a67042209a2494ae4c50c5e4317888226" title="Automatically look for available WLAN, non-WLAN or loopback interfaces. ">wlanLookup()</a>, as last argument, when more than one wireless interface is available on the system.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">stream</td><td>File stream to print to (a file, <em>stdout</em> or <em>stderr</em>)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><b>0</b> if no error occurred, or, in case of error, a <a class="el" href="rawsock_8h.html#a69f2206781eb90dcf48b8be85a62f900">rawsockerr_t</a> error:<ul>
<li><em>ERR_VIFPRINTER_SOCK</em> -&gt; cannot create socket to look for available interfaces</li>
<li><em>ERR_VIFPRINTER_GETIFADDRS</em> -&gt; error in calling <code>getifaddrs()</code> </li>
</ul>
</dd></dl>

<p>Definition at line <a class="el" href="rawsock_8c_source.html#l00327">327</a> of file <a class="el" href="rawsock_8c_source.html">rawsock.c</a>.</p>

</div>
</div>
<a class="anchor" id="a67042209a2494ae4c50c5e4317888226"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="rawsock_8h.html#a69f2206781eb90dcf48b8be85a62f900">rawsockerr_t</a> wlanLookup </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>devname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>ifindex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="rawsock_8h.html#a7516f6c5689b1c204b2bb4f05b09e1cf">macaddr_t</a>&#160;</td>
          <td class="paramname"><em>mac</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct in_addr *&#160;</td>
          <td class="paramname"><em>srcIP</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Automatically look for available WLAN, non-WLAN or loopback interfaces. </p>
<p>This function can be used to automatically look for available and ready WLAN or non-WLAN (depending on <em>mode</em>) interfaces in the system.</p>
<p>From version 0.2.0 it is also possible to specify <a class="el" href="rawsock_8h.html#aff64daee24d50575c816c5d75874d001">WLANLOOKUP_LOOPBACK</a> as <em>index</em> to look for the first available lookback interface, instead of WLAN/non-WLAN ones.</p>
<p>When only one interface is available and <code>0</code> is specified as index, that interface name is returned inside <code>devname</code>. Then, if the other three arguments are not NULL, the interface index, the corresponding source MAC address (if available) and the corresponding source IP address (if available) are respectively returned.</p>
<p>If more than one interface is present, the number of available interfaces of the specified type (WLAN/non-WLAN) is returned by the function and <em>index</em> is used to point to a specific interface (for instance <code>index=1</code> can be used to point to a possible <code>wlan1</code> interface when <em>mode</em> is <a class="el" href="rawsock_8h.html#aa13ccea41ef8a2be5418a024491ab3cb">WLANLOOKUP_WLAN</a>).</p>
<p>To print the available indeces, the user can use <a class="el" href="rawsock_8h.html#aad9c02628ca1d54590c3bececec86b57" title="Print information about available interfaces. ">vifPrinter()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">devname</td><td>Name of the WLAN interface. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">ifindex</td><td>Interface index corresponding to <em>devname</em> (filled in only if non-NULL). </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">mac</td><td>Interface (source) MAC address (filled in only if non-NULL / non-<a class="el" href="rawsock_8h.html#addf164de7bf1717f1fea7fc8c131df8c">MAC_NULL</a>). </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">srcIP</td><td>Interface (source) IPv4 address (filled in only if non-NULL and returned inside a <em>struct in_addr</em>, which should be available in the calling module). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>Integer index used to point to a specific interface of the specified type (i.e. using the specified <em>mode</em>), when more than one is available (or equal to <a class="el" href="rawsock_8h.html#aff64daee24d50575c816c5d75874d001">WLANLOOKUP_LOOPBACK</a> to look for the first available loopback interface). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mode</td><td>Operating mode: <a class="el" href="rawsock_8h.html#aa13ccea41ef8a2be5418a024491ab3cb">WLANLOOKUP_WLAN</a> to look for available WLAN interfaces only, <a class="el" href="rawsock_8h.html#a8a4daab19d5e118e848deaa847b17646">WLANLOOKUP_NONWLAN</a> to look for available non-WLAN/Ethernet interfaces only</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of WLAN/non-WLAN interfaces that were found, <b> &gt; 0 </b>, or, in case of error, a <a class="el" href="rawsock_8h.html#a69f2206781eb90dcf48b8be85a62f900">rawsockerr_t</a> error:<ul>
<li><em>ERR_WLAN_NOIF</em> -&gt; no interfaces found</li>
<li><em>ERR_WLAN_SOCK</em> -&gt; cannot create socket to look for available and running interfaces</li>
<li><em>ERR_WLAN_GETIFADDRS</em> -&gt; error in calling <code>getifaddrs()</code></li>
<li><em>ERR_WLAN_INDEX</em> -&gt; invalid index value</li>
<li><em>ERR_WLAN_GETSRCMAC</em> -&gt; unable to get source MAC address (if requested)</li>
<li><em>ERR_WLAN_GETIFINDEX</em> -&gt; unable to get source interface index (if requested)</li>
<li><em>ERR_WLAN_GETSRCMAC</em> -&gt; unable to get source IP address (if requested) </li>
</ul>
</dd></dl>

<p>Definition at line <a class="el" href="rawsock_8c_source.html#l00149">149</a> of file <a class="el" href="rawsock_8c_source.html">rawsock.c</a>.</p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="dir_22e672335d01195fb093ee3980f2d937.html">Rawsock_lib</a></li><li class="navelem"><a class="el" href="rawsock_8h.html">rawsock.h</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.11 </li>
  </ul>
</div>
</body>
</html>
